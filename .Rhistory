setwd('~/Documents/WHOI/RData/BaskingSharks/2008/88144/')
ptt <- 88144
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
pdt <- pdt[,c(grep('X.Ox', colnames(pdt)) * -1)]
pdt <- pdt[,c(grep('Disc', colnames(pdt)) * -1)]
str(pdt)
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
str(pdt)
grep('X.Ox', colnames(pdt))
any(grep('X.Ox', colnames(pdt)))
any(grep('Min', colnames(pdt)))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
if(any(grep('X.Ox', colnames(pdt)))){
pdt <- pdt[,c(grep('X.Ox', colnames(pdt)) * -1)]
pdt <- pdt[,c(grep('Disc', colnames(pdt)) * -1)]
}
pdt <- extract.pdt(pdt)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
setwd('~/Documents/WHOI/RData/BaskingSharks/2008/88144/')
ptt <- 88144
iniloc <- data.frame(matrix(c(11, 10, 2008, 42.0650, -70.2893,
1, 8, 2009, 42.085, -70.333), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
if(any(grep('X.Ox', colnames(pdt)))){
pdt <- pdt[,c(grep('X.Ox', colnames(pdt)) * -1)]
pdt <- pdt[,c(grep('Disc', colnames(pdt)) * -1)]
}
pdt <- extract.pdt(pdt)
str(pdt)
pdt <- pdt[!is.na(pdt$Depth),]
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
didx <- dts >= tag & dts <= pop
pdt <- pdt[didx,]
str(pdt)
head(pdt)
tail(pdt)
pop
lon = c(-70, -15)
lat = c(20, 60)
ohc.dir <- paste('~/Documents/WHOI/RData/HYCOM/', ptt, '/',sep = '')
udates <- unique(as.Date(pdt$Date))
limits = c(lon,lat) # (min long, max long, min lat, max lat)
nc.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(nc.dir, limits, resolution = 'quarter')
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
iniloc
lon = c(-90, -30)
lat = c(-30, 50)
limits = c(lon,lat) # (min long, max long, min lat, max lat)
nc.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(nc.dir, limits, resolution = 'quarter')
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
# eliminate Pacific from matching
dat = removePacific(dat, lat, lon)
str(dat)
str(lon)
image.plot(lon,lat,dat[,,1,1])
data(countriesLow)
plot(countriesLow,add=T)
L.pdt = calc.pdt(pdt, dat, lat, lon)
str(L.pdt)
image.plot(lon,lat,L.pdt[,,1])
image.plot(lon,lat,L.pdt[,,10])
image.plot(lon,lat,L.pdt[,,30])
image.plot(lon,lat,L.pdt[,,50])
max(L.pdt[,,50],na.rm=T)
str(L.pdt[,,50])
image.plot(lon,lat,L.pdt[,,50])
image.plot(lon,lat,L.pdt[,,60])
image.plot(lon,lat,L.pdt[,,90])
pdt
iniloc <- data.frame(matrix(c(11, 10, 2008, 42.0650, -70.2893,
1, 10, 2009, 42.105, -68.34), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
setwd('~/Documents/WHOI/RData/BaskingSharks/2008/88143/')
ptt <- 88143
iniloc <- data.frame(matrix(c(11, 10, 2008, 42.0650, -70.2893,
1, 10, 2009, 42.105, -68.34), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
if(any(grep('X.Ox', colnames(pdt)))){
pdt <- pdt[,c(grep('X.Ox', colnames(pdt)) * -1)]
pdt <- pdt[,c(grep('Disc', colnames(pdt)) * -1)]
}
pdt <- extract.pdt(pdt)
pdt <- pdt[!is.na(pdt$Depth),]
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
didx <- dts >= tag & dts <= pop
pdt <- pdt[didx,]
lon = c(-90, -30)
lat = c(-30, 50)
str(pdt)
udates <- unique(as.Date(pdt$Date))
limits = c(lon,lat) # (min long, max long, min lat, max lat)
nc.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(nc.dir, limits, resolution = 'quarter')
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
# eliminate Pacific from matching
dat = removePacific(dat, lat, lon)
image.plot(lon,lat,dat[,,1,1])
L.pdt = calc.pdt(pdt, dat, lat, lon)
str(L.pdt)
tail(L.pdt)
tail(pdt)
image.plot(lon,lat,L.pdt[,,1])
image.plot(lon,lat,L.pdt[,,10])
image.plot(lon,lat,L.pdt[,,30])
max(L.pdt[,,30],na.rm=T)
image.plot(lon,lat,L.pdt[,,31])
image.plot(lon,lat,L.pdt[,,50])
image.plot(lon,lat,L.pdt[,,60])
image.plot(lon,lat,L.pdt[,,80])
image.plot(lon,lat,L.pdt[,,90])
image.plot(lon,lat,L.pdt[,,95])
image.plot(lon,lat,L.pdt[,,100])
image.plot(lon,lat,L.pdt[,,105])
image.plot(lon,lat,L.pdt[,,110])
image.plot(lon,lat,L.pdt[,,130])
image.plot(lon,lat,L.pdt[,,140])
image.plot(lon,lat,L.pdt[,,150])
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
#light <- light[light$Type == 'GPE',]
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
head(dts)
didx <- dts > tag & dts < pop
locs <- locs[didx,]
str(locs)
ngrid <- c(limits[2] - limits[1], limits[4] - limits[3])
g <- setup.grid(locs)
lon <- g$lon[1,]
lat <- g$lat[,1]
colnames(iniloc) = list('day','month','year','lat','lon')
L.locs <- lik.locs(locs, iniloc, g)
iniloc
class(iniloc)
str(L)
str(L.locs)
L.locs <- lik.locs(locs, iniloc, g)
lik.locs <- function(locs,iniloc,g){
## Calculate the "data" likelihood, i.e. the likelihood field for each observation
#' @param: locs is -Locations file output from DAP for WC tags and contains
#'        GPS, Argos, and GPE locations as applicable
#' @param: iniloc is 2 x 5 dataframe containing day, month, year,
#'          lat, lon for both tag and pop locations
#' @param: g is output from setup.grid and indicates extent and resolution
#'        of grid used to calculate likelihoods
#' @return:
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L <- array(0,dim=c(col, row, T + 2))
# Initial location is known
ilo <- which.min(abs(g$lon[1,]-iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1]-iniloc$lat[1]))
L[ilo, ila, 1] <- 1
# Calculate data likelihood
# SD for light-based longitude from Musyl et al. (2001)
sl.sd <- 35/111 # Converting from kms to degrees
for(t in 1:T){
if(locs$Type[t] == 'GPS'){
glo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
gla <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L[glo, gla, (t+1)] <- 1
} else if(locs$Type[t] == 'Argos'){
alo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
ala <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L[alo, ala, (t+1)] <- 1
} else if(locs$Type[t] == 'GPE'){
L.light <- dnorm(t(g$lon), locs$Longitude[t], sl.sd) # Longitude data
L[,, (t + 1)] <- (L.light / max(L.light, na.rm = T)) - .05
} else{}
#time <- date2time(as.POSIXct(light$Date[t], format = findDateFormat(light$Date)))
#L[,,t] <- Lsst*Llon
}
# End location is known
elo <- which.min(abs(g$lon[1,]-iniloc$lon[2]))
ela <- which.min(abs(g$lat[,1]-iniloc$lat[2]))
L[elo, ela, T + 2] <- 1
L
}
L.locs <- lik.locs(locs, iniloc, g)
str(L.locs)
lik.locs <- function(locs,iniloc,g){
## Calculate the "data" likelihood, i.e. the likelihood field for each
## location observation
#' @param: locs is -Locations file output from DAP for WC tags and contains
#'        GPS, Argos, and GPE locations as applicable
#' @param: iniloc is 2 x 5 dataframe containing day, month, year,
#'          lat, lon for both tag and pop locations
#' @param: g is output from setup.grid and indicates extent and resolution
#'        of grid used to calculate likelihoods
#' @return: L is array of lon x lat likelihood surfaces (matrices)
#'          for each time point (3rd dimension)
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L <- array(0,dim=c(col, row, T + 2))
# Initial location is known
ilo <- which.min(abs(g$lon[1,]-iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1]-iniloc$lat[1]))
L[ilo, ila, 1] <- 1
# Calculate data likelihood
# SD for light-based longitude from Musyl et al. (2001)
sl.sd <- 35/111 # Converting from kms to degrees
for(t in 1:T){
if(locs$Type[t] == 'GPS'){
# if GPS exists then other forms of data for that time point are obsolete
glo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
gla <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L[glo, gla, (t+1)] <- 1
} else if(locs$Type[t] == 'Argos'){
# if Argos exists, GPE positions are obsolete
alo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
ala <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L[alo, ala, (t+1)] <- 1
} else if(locs$Type[t] == 'GPE'){
# create longitude likelihood based on GPE data
# for now, latitude is ignored
L.light <- dnorm(t(g$lon), locs$Longitude[t], sl.sd) # Longitude data
L[,, (t + 1)] <- (L.light / max(L.light, na.rm = T)) - .05
} else{}
}
# End location is known
elo <- which.min(abs(g$lon[1,]-iniloc$lon[2]))
ela <- which.min(abs(g$lat[,1]-iniloc$lat[2]))
L[elo, ela, T + 2] <- 1
return(L)
}
L.locs <- lik.locs(locs, iniloc, g)
str(L.locs)
image.plot(lon,lat,L.locs[,,1])
image.plot(lon,lat,L.locs[,,10])
?@param
?"@"
?error
?stop
??inverse
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
str(locs)
g <- setup.grid(locs)
str(g)
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- lik.locs(locs, iniloc, g)
str(L.locs)
image.plot(lon,lat,L.locs[,,1])
image.plot(lon,lat,L.locs[,,2])
image.plot(lon,lat,L.locs[,,10])
image.plot(lon,lat,L.locs[,,30])
