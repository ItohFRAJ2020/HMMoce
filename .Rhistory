print(time)
#     } else{
#       # what to do if y<3?
#     }
}
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
list.pdt <- list(x = lon, y = lat, z = L.pdt)
ex <- extent(list.pdt)
L.pdt <- brick(list.pdt$z, xmn=ex[1], xmx=ex[2], ymn=ex[3], ymx=ex[4], transpose=T, crs)
L.pdt <- flip(L.pdt, direction = 'y')
# make L.pdt match resolution/extent of g
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
ex <- extent(c(min(g$lon[1,]), max(g$lon[1,]), min(g$lat[,1]), max(g$lat[,1])))
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
rasMatch <- raster(ex, nrows=row, ncols=col, crs = crs)
L.pdt <- spatial_sync_raster(L.pdt, rasMatch)
if(raster == 'brick'){
s <- L.pdt
} else if(raster == 'stack'){
s <- stack(L.pdt)
} else if(raster == 'array'){
s <- raster::as.array(L.pdt, transpose = T)
}
print(class(s))
return(s)
}
L.pdt <- calc.pdt.int(pdt.sub, dat = dat1, lat = dat$lat, lon = dat$lon, g, depth = dat$depth, raster = 'stack', dateVec = dateVec.sub)
L.pdt
plot(L.pdt[[10]])
plot(countriesLow, add = T)
dateVec[10]
pdt.sub
plot(L.pdt[[1]])
plot(countriesLow, add = T)
plot(L.pdt[[2]])
plot(countriesLow, add = T)
plot(L.pdt[[3]])
plot(countriesLow, add = T)
plot(L.pdt[[4]])
plot(countriesLow, add = T)
plot(L.pdt[[5]])
plot(countriesLow, add = T)
plot(L.pdt[[6]])
plot(countriesLow, add = T)
plot(L.pdt[[7]])
plot(countriesLow, add = T)
plot(L.pdt[[9]])
plot(countriesLow, add = T)
plot(L.pdt[[8]])
plot(countriesLow, add = T)
plot(L.pdt[[10]])
plot(countriesLow, add = T)
spot = read.csv('~/Documents/WHOI/RData/WhiteSharks/2013/121325/121325-SPOT.csv')
dts <- as.POSIXct(spot$Date, format=findDateFormat(spot$Date))
didx <- dts >= tag & dts <= pop
spot <- spot[didx,]
dateVec[10]
str(spot)
spot
udates <- unique(pdt$Date)
T <- length(udates)
pdt$MidTemp <- (pdt$MaxTemp + pdt$MinTemp) / 2
L.pdt <- array(0, dim = c(dim(dat)[1:2], length(dateVec)))
i=10
time <- udates[i]
time
dateVec[10]
pdt.i <- pdt[which(pdt$Date == time),]
pdt.i <- pdt[which(pdt$Date == time),]
dy <- pdt.i$Depth[!is.na(pdt.i$Depth)] #extracts depth from tag data for day i
y[y<0] <- 0
y <- pdt.i$Depth[!is.na(pdt.i$Depth)] #extracts depth from tag data for day i
y[y<0] <- 0
rm(dy)
y
x <- pdt.i$MidTemp[!is.na(pdt.i$Depth)]  #extract temperature from tag data for day i
x
depIdx = apply(as.data.frame(pdt.i$Depth), 1, FUN=function(x) which.min((x-depth)^2))
depth = dat$depth
lon = dat$lon
lat = dat$lat
str(dat)
x <- pdt.i$MidTemp[!is.na(pdt.i$Depth)]  #extract temperature from tag data for day i
# use the which.min
# depIdx = apply(as.data.frame(deps), 1, FUN=function(x) which.min((x-stdDepth)^2))
depIdx = apply(as.data.frame(pdt.i$Depth), 1, FUN=function(x) which.min((x-depth)^2))
woaDep <- depth[depIdx]
depIdx
woaDep
fit.low <- locfit(pdt.i$MinTemp ~ pdt.i$Depth)
fit.high <- locfit(pdt.i$MaxTemp ~ pdt.i$Depth)
n = length(depth)
#     pred = predict(fit, newdata = depth, se = T, get.data = T)
pred.low = predict(fit.low, newdata = depth, se = T, get.data = T)
pred.high = predict(fit.high, newdata = depth, se = T, get.data = T)
# data frame for next step
df = data.frame(low=pred.low$fit[depIdx]-pred.low$se.fit[depIdx]*sqrt(n)
, high=pred.high$fit[depIdx]+pred.high$se.fit[depIdx]*sqrt(n)
, depth = depth[depIdx])
str(df)
plot(df$depth)
lines(df$low)
plot(df$depth)
lines(df$depth-df$low)
lines(df$depth+df$high)
pdtMonth <- as.numeric(format(as.Date(pdt.i$Date), format='%m'))[1]
dat <- dat$dat
dat.i = dat[,,,pdtMonth] #extract months climatology
dat.i[is.na(dat.i)] = -9999
sdr = (df[,2]-df[,1])/4
sdr
lik.pdt = array(1e-15, dim=c(dim(dat)[1], dim(dat)[2], length(depIdx)))
likint
lik.pdt[,,b] = likint(dat.i[,,b], df[b,1], df[b,2], sdr[b])
for (b in 1:length(depIdx)) {
# sequence
# NO..
# dt = seq(df$low[b], df$high[b], length = 10)
# likelihood array for one depth
#       lik0 = aaply(
#         dt, 1, .fun = function(z)
#           dnorm(x[b], dat[,,depIdx[b],pdtMonth], sdx)
#       )
# lik.b.int = apply(lik0, 2:3, sum)
lik.pdt[,,b] = likint(dat.i[,,b], df[b,1], df[b,2], sdr[b])
# calculate likelihood at each depth for a given tag time point
#lik.b <- dnorm(dat[,, b, pdtMonth], tag$x[which(depIdx == b)], sdx)
#lik.b <- (lik.b / max(lik.b, na.rm = T)) - .05
#       if (b == 1) {
#         lik.pdt <- as.array(lik.b.int)
#       } else{
#         lik.pdt <- abind(lik.pdt, lik.b.int, along = 3)
#       }
}
str(lik.pdt)
image.plot(lik.pdt[,,1])
image.plot(lik.pdt[,,2])
image.plot(lik.pdt[,,3])
image.plot(lik.pdt[,,4])
image.plot(lik.pdt[,,5])
image.plot(lik.pdt[,,6])
woaDep
image.plot(lik.pdt[,,7])
image.plot(lik.pdt[,,8])
depIdx
str(dat)
pdtMonth
image.plot(dat[,,31,pdtMonth])
pdt.i
sdr
for (b in 1:length(depIdx)) {
# sequence
# NO..
# dt = seq(df$low[b], df$high[b], length = 10)
# likelihood array for one depth
#       lik0 = aaply(
#         dt, 1, .fun = function(z)
#           dnorm(x[b], dat[,,depIdx[b],pdtMonth], sdx)
#       )
# lik.b.int = apply(lik0, 2:3, sum)
lik.pdt[,,b] = likint(dat.i[,,b], df[b,1], df[b,2], sdr[b]+1)
# calculate likelihood at each depth for a given tag time point
#lik.b <- dnorm(dat[,, b, pdtMonth], tag$x[which(depIdx == b)], sdx)
#lik.b <- (lik.b / max(lik.b, na.rm = T)) - .05
#       if (b == 1) {
#         lik.pdt <- as.array(lik.b.int)
#       } else{
#         lik.pdt <- abind(lik.pdt, lik.b.int, along = 3)
#       }
}
image.plot(lik.pdt[,,8])
for (b in 1:length(depIdx)) {
# sequence
# NO..
# dt = seq(df$low[b], df$high[b], length = 10)
# likelihood array for one depth
#       lik0 = aaply(
#         dt, 1, .fun = function(z)
#           dnorm(x[b], dat[,,depIdx[b],pdtMonth], sdx)
#       )
# lik.b.int = apply(lik0, 2:3, sum)
lik.pdt[,,b] = likint(dat.i[,,b], df[b,1], df[b,2], sdr[b]+3)
# calculate likelihood at each depth for a given tag time point
#lik.b <- dnorm(dat[,, b, pdtMonth], tag$x[which(depIdx == b)], sdx)
#lik.b <- (lik.b / max(lik.b, na.rm = T)) - .05
#       if (b == 1) {
#         lik.pdt <- as.array(lik.b.int)
#       } else{
#         lik.pdt <- abind(lik.pdt, lik.b.int, along = 3)
#       }
}
image.plot(lik.pdt[,,8])
i
i=5
time <- udates[i]
pdt.i <- pdt[which(pdt$Date == time),]
y <- pdt.i$Depth[!is.na(pdt.i$Depth)] #extracts depth from tag data for day i
y[y<0] <- 0
# if (length(y) >= 3){
x <- pdt.i$MidTemp[!is.na(pdt.i$Depth)]  #extract temperature from tag data for day i
# use the which.min
# depIdx = apply(as.data.frame(deps), 1, FUN=function(x) which.min((x-stdDepth)^2))
depIdx = apply(as.data.frame(pdt.i$Depth), 1, FUN=function(x) which.min((x-depth)^2))
woaDep <- depth[depIdx]
woaDep
fit.low <- locfit(pdt.i$MinTemp ~ pdt.i$Depth)
fit.high <- locfit(pdt.i$MaxTemp ~ pdt.i$Depth)
n = length(depth)
#     pred = predict(fit, newdata = depth, se = T, get.data = T)
pred.low = predict(fit.low, newdata = depth, se = T, get.data = T)
pred.high = predict(fit.high, newdata = depth, se = T, get.data = T)
# data frame for next step
df = data.frame(low=pred.low$fit[depIdx]-pred.low$se.fit[depIdx]*sqrt(n)
, high=pred.high$fit[depIdx]+pred.high$se.fit[depIdx]*sqrt(n)
, depth = depth[depIdx])
df
pdt.i$MinTemp
pdt.i
pdt.i$Depth
fit.low
plot(fit.low)
plot(fit.high)
pred.low
df
pred.low$fit[depIdx]
pred.low$se.fit[depIdx]
n
i=10
time <- udates[i]
pdt.i <- pdt[which(pdt$Date == time),]
y <- pdt.i$Depth[!is.na(pdt.i$Depth)] #extracts depth from tag data for day i
y[y<0] <- 0
# if (length(y) >= 3){
x <- pdt.i$MidTemp[!is.na(pdt.i$Depth)]  #extract temperature from tag data for day i
# use the which.min
# depIdx = apply(as.data.frame(deps), 1, FUN=function(x) which.min((x-stdDepth)^2))
depIdx = apply(as.data.frame(pdt.i$Depth), 1, FUN=function(x) which.min((x-depth)^2))
woaDep <- depth[depIdx]
# make predictions based on the regression model earlier for the temperature at standard WOA depth levels for low and high temperature at that depth
fit.low <- locfit(pdt.i$MinTemp ~ pdt.i$Depth)
fit.high <- locfit(pdt.i$MaxTemp ~ pdt.i$Depth)
n = length(depth)
#     pred = predict(fit, newdata = depth, se = T, get.data = T)
pred.low = predict(fit.low, newdata = depth, se = T, get.data = T)
pred.high = predict(fit.high, newdata = depth, se = T, get.data = T)
# data frame for next step
df = data.frame(low=pred.low$fit[depIdx]-pred.low$se.fit[depIdx]*sqrt(n)
, high=pred.high$fit[depIdx]+pred.high$se.fit[depIdx]*sqrt(n)
, depth = depth[depIdx])
df
n
pred.low$fit[depIdx]
pred.low$se.fit[depIdx]
pred.low = predict(fit.low, newdata = depth[depIdx], se = T, get.data = T)
pred.low
n = length(depth[depIdx])
#     pred = predict(fit, newdata = depth, se = T, get.data = T)
pred.low = predict(fit.low, newdata = depth[depIdx], se = T, get.data = T)
pred.high = predict(fit.high, newdata = depth[depIdx], se = T, get.data = T)
df = data.frame(low=pred.low$fit[depIdx]-pred.low$se.fit[depIdx]*sqrt(n)
, high=pred.high$fit[depIdx]+pred.high$se.fit[depIdx]*sqrt(n)
, depth = depth[depIdx])
df
woaDep
depIdx
pred.low
pred.high
n
pred.low$se.fit[depIdx]
df = data.frame(low=pred.low$fit-pred.low$se.fit*sqrt(n)
, high=pred.high$fit+pred.high$se.fit*sqrt(n)
, depth = depth)
df
df = data.frame(low=pred.low$fit-pred.low$se.fit*sqrt(n)
, high=pred.high$fit+pred.high$se.fit*sqrt(n)
, depth = depth[depIdx])
df
pdt.i
?predict
pred.low = predict(fit.low, newdata = depth[depIdx], se = T, get.data = T)
pred.low.all = predict(fit.low, newdata = depth, se = T, get.data = T)
pred.low$se.fit
pred.low.all$se.fit
plot(fit,get.data=T,lwd=2)
plot(fit.low,get.data=T,lwd=2)
lines(fit.high)
lines(fit.high,get.data=T)
lines(pdt.i$MidTemp~pdt.i$Depth)
plot(pdt.i$MinTemp~pdt.i$Depth)
lines(woaDep, pred.high$fit+pred.high$se.fit*sqrt(n), col=4, lty=2)
lines(woaDep, pred.low$fit-pred.low$se.fit*sqrt(n), col=4, lty=2)
lines(depth, pred.low.all$fit-pred.low.all$se.fit*sqrt(57))
plot(pdt.i$MidTemp~pdt.i$Depth,type='l')
points(pdt.i$MinTemp~pdt.i$Depth)
points(pdt.i$MaxTemp~pdt.i$Depth)
lines(woaDep, pred.high$fit+pred.high$se.fit*sqrt(n), col=4, lty=2)
lines(woaDep, pred.low$fit-pred.low$se.fit*sqrt(n), col=4, lty=2)
pred.high.all = predict(fit.high, newdata = depth, se = T, get.data = T)
lines(depth, pred.low.all$fit-pred.low.all$se.fit*sqrt(57))
lines(depth, pred.high.all$fit-pred.high.all$se.fit*sqrt(57))
pred.high.all
plot(pdt.i$MidTemp~pdt.i$Depth,type='l')
points(pdt.i$MinTemp~pdt.i$Depth)
points(pdt.i$MaxTemp~pdt.i$Depth)
lines(woaDep, pred.high$fit+pred.high$se.fit*sqrt(n), col=4, lty=2)
lines(woaDep, pred.low$fit-pred.low$se.fit*sqrt(n), col=4, lty=2)
lines(depth, pred.low.all$fit-pred.low.all$se.fit*sqrt(57))
lines(depth, pred.high.all$fit+pred.high.all$se.fit*sqrt(57))
plot(pdt.i$MidTemp~pdt.i$Depth,type='l',xlim=c(0,370),ylim=c(8,24))
points(pdt.i$MinTemp~pdt.i$Depth)
points(pdt.i$MaxTemp~pdt.i$Depth)
lines(woaDep, pred.high$fit+pred.high$se.fit*sqrt(n), col=4, lty=2)
lines(woaDep, pred.low$fit-pred.low$se.fit*sqrt(n), col=4, lty=2)
lines(depth, pred.low.all$fit-pred.low.all$se.fit*sqrt(57))
lines(depth, pred.high.all$fit+pred.high.all$se.fit*sqrt(57))
length(udates)
tag
pop
head(udates)
tail(udates)
?integrate
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
data("countriesLow")
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
plot(L.locs[[4]])
plot(countriesLow, add = T)
limits = c(min(lon)-3, max(lon)+3, min(lat)-3, max(lat)+3)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa;
dat$lon = as.numeric(dat$lon);
dat$lat = as.numeric(dat$lat);
dat$depth = as.numeric(dat$depth)
dat$dat = removePacific(dat$dat, dat$lat, dat$lon)
# check woa data
graphics.off()
image.plot(dat$lon,dat$lat,dat$dat[,,1,1])
L.pdt <- calc.pdt.int(pdt, dat = dat, lat = dat$lat, lon = dat$lon, g, depth = dat$depth, raster = 'stack', dateVec = dateVec)
L.pdt <- calc.pdt.int(pdt, dat = dat$dat, lat = dat$lat, lon = dat$lon, g, depth = dat$depth, raster = 'stack', dateVec = dateVec)
L.pdt
list.pdt
devtools::load_all(".")
likint
array(NA, dim=c(2,3,3))
library(locfit)
library(fields)
library(raster)
library(imager)
library(ncdf)
library(plyr)
#library(abind) # don't need this with modified funciton
#library(reshape2) #need this?
library(rworldmap)
library(spatial.tools)
library(magic)
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
data("countriesLow")
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
plot(L.locs[[4]])
plot(countriesLow, add = T)
limits = c(min(lon)-3, max(lon)+3, min(lat)-3, max(lat)+3)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa;
dat$lon = as.numeric(dat$lon);
dat$lat = as.numeric(dat$lat);
dat$depth = as.numeric(dat$depth)
# eliminate Pacific from woa data
dat$dat = removePacific(dat$dat, dat$lat, dat$lon)
# check woa data
graphics.off()
image.plot(dat$lon,dat$lat,dat$dat[,,1,1])
pdt.sub <- pdt[c(1:max(which(as.Date(pdt$Date) %in% dateVec[49]))),]
dateVec.sub <- dateVec[1:49]
dat = dat$dat
lat = dat$lat
lat
udates <- unique(pdt$Date)
T <- length(udates)
pdt$MidTemp <- (pdt$MaxTemp + pdt$MinTemp) / 2
L.pdt <- array(NA, dim = c(dim(dat)[1:2], length(dateVec)))
i=1
time <- udates[i]
pdt.i <- pdt[which(pdt$Date == time),]
y <- pdt.i$Depth[!is.na(pdt.i$Depth)]
y[y<0] <- 0
y
x <- pdt.i$MidTemp[!is.na(pdt.i$Depth)]
# use the which.min
depIdx = apply(as.data.frame(pdt.i$Depth), 1, FUN=function(x) which.min((x-depth)^2))
woaDep <- depth[depIdx]
depth
dat = return.woa;
dat$lon = as.numeric(dat$lon);
dat$lat = as.numeric(dat$lat);
dat$depth = as.numeric(dat$depth)
depth = as.numeric(dat$depth)
lat = as.numeric(dat$lat)
lon = as.numeric(dat$lon)
dat$dat = removePacific(dat$dat, dat$lat, dat$lon)
depIdx = apply(as.data.frame(pdt.i$Depth), 1, FUN=function(x) which.min((x-depth)^2))
woaDep <- depth[depIdx]
woaDep
# make predictions based on the regression model earlier for the temperature at standard WOA depth levels for low and high temperature at that depth
fit.low <- locfit(pdt.i$MinTemp ~ pdt.i$Depth)
fit.high <- locfit(pdt.i$MaxTemp ~ pdt.i$Depth)
n = length(depth[depIdx])
pred.low = predict(fit.low, newdata = depth[depIdx], se = T, get.data = T)
pred.high = predict(fit.high, newdata = depth[depIdx], se = T, get.data = T)
# data frame for next step
df = data.frame(low=pred.low$fit-pred.low$se.fit*sqrt(n)
, high=pred.high$fit+pred.high$se.fit*sqrt(n)
, depth = depth[depIdx])
pdtMonth <- as.numeric(format(as.Date(pdt.i$Date), format='%m'))[1]
dat.i = dat[,,,pdtMonth] #extract months climatology
dat.i[is.na(dat.i)] = -9999
pdt.i$Date
pdtMonth <- as.numeric(format(as.Date(pdt.i$Date), format='%m'))[1]
pdtMonth
str(dat)
dat = dat$dat
dat.i = dat[,,,pdtMonth] #extract months climatology
dat.i[is.na(dat.i)] = -9999
sdx <- .7
lik.pdt = array(NA, dim=c(dim(dat)[1], dim(dat)[2], length(depIdx)))
for (b in 1:length(depIdx)) {
#calculate the likelihood for each depth level, b
lik.pdt[,,b] = likint(dat.i[,,b], df[b,1], df[b,2], sdx)
}
str(lik.pdt)
image.plot(lik.pdt[,,1])
image.plot(lik.pdt[,,3])
lik.pdt <- apply(lik.pdt, 1:2, function(x) prod(na.omit(x)))
str(lik.pdt)
image.plot(lik.pdt)
?na.omit
DF <- data.frame(x = c(1, 2, 3), y = c(0, 10, NA))
na.omit(DF)
DF
m <- as.matrix(DF);m
na.omit(m)
na.exclude(m)
lik.pdt = array(NA, dim=c(dim(dat)[1], dim(dat)[2], length(depIdx)))
for (b in 1:length(depIdx)) {
#calculate the likelihood for each depth level, b
lik.pdt[,,b] = likint(dat.i[,,b], df[b,1], df[b,2], sdx)
}
lik.pdt.naomit <- apply(lik.pdt, 1:2, function(x) prod(na.omit(x)))
lik.pdt.narm <- apply(lik.pdt, 1:2, prod, na.rm=T)
str(lik.pdt.narm)
str(lik.pdt.naomit)
image.plot(lik.pdt.narm-lik.pdt.naomit)
image.plot(lik.pdt.narm)
?apply
trymat <- matrix(c(c(1,2,3),c(NA,2,1)),ncol=3,nrow=2)
trymat
apply(trymat,1,prod,na.rm=T)
apply(trymat,1,function(x) prod(na.omit(x)))
devtools::load_all(".")
likint
