ex <- extent(list.locs)
L.locs <- brick(list.locs$z, xmn=ex[1], xmx=ex[2], ymn=ex[3], ymx=ex[4], transpose=T, crs)
L.locs <- flip(L.locs, direction = 'y')
L.locs <- stack(L.locs)
}
print(class(L.locs))
return(L.locs)
}
L.locs <- calc.locs2(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
calc.locs2 <- function(locs, iniloc, g, raster = TRUE, dateVec, errEll = F){
## Calculate the "data" likelihood, i.e. the likelihood field for each
## location observation
#' @param: locs is -Locations file output from DAP for WC tags and contains
#'        GPS, Argos, and GPE locations as applicable
#' @param: iniloc is 2 x 5 dataframe containing day, month, year,
#'          lat, lon for both tag and pop locations
#' @param: g is output from setup.grid and indicates extent and resolution
#'        of grid used to calculate likelihoods
#' @param errEll is logical indicating whether error ellipses should be
#'        generated for light-based likelihoods as given from output
#'        of WC-GPE. False if only longitude should be used.
#' @return: L is array of lon x lat likelihood surfaces (matrices)
#'          for each time point (3rd dimension)
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L.locs <- array(0, dim = c(col, row, length(dateVec)))
# Initial location is known
ilo <- which.min(abs(g$lon[1,]-iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1]-iniloc$lat[1]))
L.locs[ilo, ila, 1] <- 1
# Calculate data likelihood
locDates <- as.Date(locs$Date, format = findDateFormat(locs$Date))
#g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon1 <- seq(min(g$lon[1,])-10,max(g$lon[1,])+10,by=g$dlo)
lat1 <- seq(min(g$lat[,1])-10,max(g$lat[,1])+10,by=g$dla)
g1 <- meshgrid(lon1,lat1)
locs$Offset[which(is.na(locs$Offset))] <- 0
for(t in 1:T){
if(locs$Type[t] == 'GPS'){
# if GPS exists then other forms of data for that time point are obsolete
glo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
gla <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L.locs[glo, gla, which(dateVec == locDates[t])] <- 1
} else if(locs$Type[t] == 'Argos'){
# if Argos exists, GPE positions are obsolete
alo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
ala <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L.locs[alo, ala, which(dateVec == locDates[t])] <- 1
} else if(locs$Type[t] == 'GPE'){
if(errEll == FALSE){
# create longitude likelihood based on GPE data
# for now, latitude is ignored
# SD for light-based longitude from Musyl et al. (2001)
slon.sd <- 35/111 # Converting from kms to degrees
L.light <- dnorm(t(g$lon), locs$Longitude[t], slon.sd)
L.locs[,,which(dateVec == locDates[t])] <- L.light
} else if(errEll == TRUE){
#stop('Error: Error ellipse functionality is not yet available.')
# arithmetic converts from meters to degrees (transformation due to projection?)
slon.sd <- locs$Error.Semi.minor.axis[t] / 1000 / 111 #semi minor axis
L.light.lon <- dnorm(t(g1$X), locs$Longitude[t], slon.sd) # Longitude data
slat.sd <- locs$Error.Semi.major.axis[t] / 1000 / 111 #semi major axis
L.light.lat <- dnorm(t(g1$Y), locs$Latitude[t], slat.sd)
#image.plot(g$lon[1,],g$lat[,1],L.light.lat*L.light.lon)
#draw.ellipse(-80,35,a=10,b=8)
#L.lat <- flip(raster(t(L.light.lat), xmn=min(lon),
#            xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction='y')
#plot(L.lat)
#L.lon <- flip(raster(t(L.light.lon), xmn=min(lon),
#                xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction = 'y')
#plot(L.lon)
L <- flip(raster(t(L.light.lat * L.light.lon), xmn=min(lon1),
xmx=max(lon1),ymn=min(lat1),ymx=max(lat1)), direction = 'y')
# offset
# Lext <- extent(xmin(L)-, xmax(L)+10, ymin(L)-10, ymax(L)+10)
#L1 <- raster(NA, extent=Lext)
shiftDist <- (-1 * (locs$Offset[t] / 1000 / 111))
if(shiftDist <= 10){
Ls <- shift(L, y = shiftDist)
#plot(L.new * Ls)
#L.new <- L
#L.new[L.new>=0] = 1
L.ext <- flip(raster(g$lon, xmn=min(lon),
xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction = 'y')
L.ext[L.ext<=0] = 1
#Lsx <- extend(Ls, Lext)
Lsx <- crop(Ls, L.ext)
#Lsx <- raster(matrix(extract(Ls, Lext), nrow=nrow(L), ncol=ncol(L)), xmn=min(lon),
#              xmx=max(lon),ymn=min(lat),ymx=max(lat))
# rotate?
#Lsx <- rotateProj(Lsx, locs$Error.Ellipse.orientation[t])
#xres <- lon[2] - lon[1]; yres <- lat[2] - lat[1]
#locs$Offset[t] / 1000 / 111 # offset in degrees
rr <- resample(Lsx, L.ext)
#image.plot(lon,lat,t(as.matrix(flip(rr,direction='y'))))
L.locs[,,which(dateVec == locDates[t])] <- t(as.matrix(flip(rr,direction='y')))
} else{
# if supposed shift in error ellipse is >10 degrees, we revert to longitude only
slon.sd <- 35/111 # Converting from kms to degrees
L.light <- dnorm(t(g$lon), locs$Longitude[t], slon.sd)
L.locs[,,which(dateVec == locDates[t])] <- L.light
}
}
} else{
stop('No data type for this days location.')
}
print(t)
image.plot(lon,lat,L.locs[,,which(dateVec == locDates[t])], main=paste(dateVec[which(dateVec==locDates[t])]))
}
# End location is known
elo <- which.min(abs(g$lon[1,]-iniloc$lon[2]))
ela <- which.min(abs(g$lat[,1]-iniloc$lat[2]))
L.locs[elo, ela, length(dateVec)] <- 1
if(raster){
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
list.locs <- list(x = g$lon[1,], y = g$lat[,1], z = L.locs)
ex <- extent(list.locs)
L.locs <- brick(list.locs$z, xmn=ex[1], xmx=ex[2], ymn=ex[3], ymx=ex[4], transpose=T, crs)
L.locs <- flip(L.locs, direction = 'y')
L.locs <- stack(L.locs)
}
print(class(L.locs))
return(L.locs)
}
L.locs <- calc.locs2(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L.locs <- array(0, dim = c(col, row, length(dateVec)))
# Initial location is known
ilo <- which.min(abs(g$lon[1,]-iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1]-iniloc$lat[1]))
L.locs[ilo, ila, 1] <- 1
# Calculate data likelihood
locDates <- as.Date(locs$Date, format = findDateFormat(locs$Date))
#g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon1 <- seq(min(g$lon[1,])-10,max(g$lon[1,])+10,by=g$dlo)
lat1 <- seq(min(g$lat[,1])-10,max(g$lat[,1])+10,by=g$dla)
g1 <- meshgrid(lon1,lat1)
locs$Offset[which(is.na(locs$Offset))] <- 0
locs[4,]
t=4
slon.sd <- locs$Error.Semi.minor.axis[t] / 1000 / 111 #semi minor axis
L.light.lon <- dnorm(t(g1$X), locs$Longitude[t], slon.sd) # Longitude data
slat.sd <- locs$Error.Semi.major.axis[t] / 1000 / 111 #semi major axis
L.light.lat <- dnorm(t(g1$Y), locs$Latitude[t], slat.sd)
#image.plot(g$lon[1,],g$lat[,1],L.light.lat*L.light.lon)
#draw.ellipse(-80,35,a=10,b=8)
#L.lat <- flip(raster(t(L.light.lat), xmn=min(lon),
#            xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction='y')
#plot(L.lat)
#L.lon <- flip(raster(t(L.light.lon), xmn=min(lon),
#                xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction = 'y')
#plot(L.lon)
L <- flip(raster(t(L.light.lat * L.light.lon), xmn=min(lon1),
xmx=max(lon1),ymn=min(lat1),ymx=max(lat1)), direction = 'y')
# offset
# Lext <- extent(xmin(L)-, xmax(L)+10, ymin(L)-10, ymax(L)+10)
#L1 <- raster(NA, extent=Lext)
shiftDist <- (-1 * (locs$Offset[t] / 1000 / 111))
shiftDist <= 10
shiftDist
shiftDist >= -10
shiftDist <- (-1 * (locs$Offset / 1000 / 111))
shiftDist
calc.locs2 <- function(locs, iniloc, g, raster = TRUE, dateVec, errEll = F){
## Calculate the "data" likelihood, i.e. the likelihood field for each
## location observation
#' @param: locs is -Locations file output from DAP for WC tags and contains
#'        GPS, Argos, and GPE locations as applicable
#' @param: iniloc is 2 x 5 dataframe containing day, month, year,
#'          lat, lon for both tag and pop locations
#' @param: g is output from setup.grid and indicates extent and resolution
#'        of grid used to calculate likelihoods
#' @param errEll is logical indicating whether error ellipses should be
#'        generated for light-based likelihoods as given from output
#'        of WC-GPE. False if only longitude should be used.
#' @return: L is array of lon x lat likelihood surfaces (matrices)
#'          for each time point (3rd dimension)
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L.locs <- array(0, dim = c(col, row, length(dateVec)))
# Initial location is known
ilo <- which.min(abs(g$lon[1,]-iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1]-iniloc$lat[1]))
L.locs[ilo, ila, 1] <- 1
# Calculate data likelihood
locDates <- as.Date(locs$Date, format = findDateFormat(locs$Date))
#g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon1 <- seq(min(g$lon[1,])-10,max(g$lon[1,])+10,by=g$dlo)
lat1 <- seq(min(g$lat[,1])-10,max(g$lat[,1])+10,by=g$dla)
g1 <- meshgrid(lon1,lat1)
locs$Offset[which(is.na(locs$Offset))] <- 0
for(t in 1:T){
if(locs$Type[t] == 'GPS'){
# if GPS exists then other forms of data for that time point are obsolete
glo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
gla <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L.locs[glo, gla, which(dateVec == locDates[t])] <- 1
} else if(locs$Type[t] == 'Argos'){
# if Argos exists, GPE positions are obsolete
alo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
ala <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L.locs[alo, ala, which(dateVec == locDates[t])] <- 1
} else if(locs$Type[t] == 'GPE'){
if(errEll == FALSE){
# create longitude likelihood based on GPE data
# for now, latitude is ignored
# SD for light-based longitude from Musyl et al. (2001)
slon.sd <- 35/111 # Converting from kms to degrees
L.light <- dnorm(t(g$lon), locs$Longitude[t], slon.sd)
L.locs[,,which(dateVec == locDates[t])] <- L.light
} else if(errEll == TRUE){
#stop('Error: Error ellipse functionality is not yet available.')
# arithmetic converts from meters to degrees (transformation due to projection?)
slon.sd <- locs$Error.Semi.minor.axis[t] / 1000 / 111 #semi minor axis
L.light.lon <- dnorm(t(g1$X), locs$Longitude[t], slon.sd) # Longitude data
slat.sd <- locs$Error.Semi.major.axis[t] / 1000 / 111 #semi major axis
L.light.lat <- dnorm(t(g1$Y), locs$Latitude[t], slat.sd)
#image.plot(g$lon[1,],g$lat[,1],L.light.lat*L.light.lon)
#draw.ellipse(-80,35,a=10,b=8)
#L.lat <- flip(raster(t(L.light.lat), xmn=min(lon),
#            xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction='y')
#plot(L.lat)
#L.lon <- flip(raster(t(L.light.lon), xmn=min(lon),
#                xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction = 'y')
#plot(L.lon)
L <- flip(raster(t(L.light.lat * L.light.lon), xmn=min(lon1),
xmx=max(lon1),ymn=min(lat1),ymx=max(lat1)), direction = 'y')
# offset
# Lext <- extent(xmin(L)-, xmax(L)+10, ymin(L)-10, ymax(L)+10)
#L1 <- raster(NA, extent=Lext)
shiftDist <- (-1 * (locs$Offset[t] / 1000 / 111))
if(shiftDist >= -10){
Ls <- shift(L, y = shiftDist)
#plot(L.new * Ls)
#L.new <- L
#L.new[L.new>=0] = 1
L.ext <- flip(raster(g$lon, xmn=min(lon),
xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction = 'y')
L.ext[L.ext<=0] = 1
#Lsx <- extend(Ls, Lext)
Lsx <- crop(Ls, L.ext)
#Lsx <- raster(matrix(extract(Ls, Lext), nrow=nrow(L), ncol=ncol(L)), xmn=min(lon),
#              xmx=max(lon),ymn=min(lat),ymx=max(lat))
# rotate?
#Lsx <- rotateProj(Lsx, locs$Error.Ellipse.orientation[t])
#xres <- lon[2] - lon[1]; yres <- lat[2] - lat[1]
#locs$Offset[t] / 1000 / 111 # offset in degrees
rr <- resample(Lsx, L.ext)
#image.plot(lon,lat,t(as.matrix(flip(rr,direction='y'))))
L.locs[,,which(dateVec == locDates[t])] <- t(as.matrix(flip(rr,direction='y')))
} else{
# if supposed shift in error ellipse is >10 degrees, we revert to longitude only
slon.sd <- 35/111 # Converting from kms to degrees
L.light <- dnorm(t(g$lon), locs$Longitude[t], slon.sd)
L.locs[,,which(dateVec == locDates[t])] <- L.light
}
}
} else{
stop('No data type for this days location.')
}
print(t)
image.plot(lon,lat,L.locs[,,which(dateVec == locDates[t])], main=paste(dateVec[which(dateVec==locDates[t])]))
}
# End location is known
elo <- which.min(abs(g$lon[1,]-iniloc$lon[2]))
ela <- which.min(abs(g$lat[,1]-iniloc$lat[2]))
L.locs[elo, ela, length(dateVec)] <- 1
if(raster){
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
list.locs <- list(x = g$lon[1,], y = g$lat[,1], z = L.locs)
ex <- extent(list.locs)
L.locs <- brick(list.locs$z, xmn=ex[1], xmx=ex[2], ymn=ex[3], ymx=ex[4], transpose=T, crs)
L.locs <- flip(L.locs, direction = 'y')
L.locs <- stack(L.locs)
}
print(class(L.locs))
return(L.locs)
}
data("countriesLow")
#---------------------------------------------------------------#
# read in tag data
#---------------------------------------------------------------#
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
#---------------------------------------------------------------#
# LIGHT
#---------------------------------------------------------------#
# Light-based Longitude Likelihood (ellipse error is a work in progress)
# do light first so that g is setup for both
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
calc.locs2 <- function(locs, iniloc, g, raster = TRUE, dateVec, errEll = F){
## Calculate the "data" likelihood, i.e. the likelihood field for each
## location observation
#' @param: locs is -Locations file output from DAP for WC tags and contains
#'        GPS, Argos, and GPE locations as applicable
#' @param: iniloc is 2 x 5 dataframe containing day, month, year,
#'          lat, lon for both tag and pop locations
#' @param: g is output from setup.grid and indicates extent and resolution
#'        of grid used to calculate likelihoods
#' @param errEll is logical indicating whether error ellipses should be
#'        generated for light-based likelihoods as given from output
#'        of WC-GPE. False if only longitude should be used.
#' @return: L is array of lon x lat likelihood surfaces (matrices)
#'          for each time point (3rd dimension)
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L.locs <- array(0, dim = c(col, row, length(dateVec)))
# Initial location is known
ilo <- which.min(abs(g$lon[1,]-iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1]-iniloc$lat[1]))
L.locs[ilo, ila, 1] <- 1
# Calculate data likelihood
locDates <- as.Date(locs$Date, format = findDateFormat(locs$Date))
#g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon1 <- seq(min(g$lon[1,])-10,max(g$lon[1,])+10,by=g$dlo)
lat1 <- seq(min(g$lat[,1])-10,max(g$lat[,1])+10,by=g$dla)
g1 <- meshgrid(lon1,lat1)
locs$Offset[which(is.na(locs$Offset))] <- 0
for(t in 1:T){
if(locs$Type[t] == 'GPS'){
# if GPS exists then other forms of data for that time point are obsolete
glo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
gla <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L.locs[glo, gla, which(dateVec == locDates[t])] <- 1
} else if(locs$Type[t] == 'Argos'){
# if Argos exists, GPE positions are obsolete
alo <- which.min(abs(g$lon[1,]-locs$Longitude[t]))
ala <- which.min(abs(g$lat[,1]-locs$Latitude[t]))
L.locs[alo, ala, which(dateVec == locDates[t])] <- 1
} else if(locs$Type[t] == 'GPE'){
if(errEll == FALSE){
# create longitude likelihood based on GPE data
# for now, latitude is ignored
# SD for light-based longitude from Musyl et al. (2001)
slon.sd <- 35/111 # Converting from kms to degrees
L.light <- dnorm(t(g$lon), locs$Longitude[t], slon.sd)
L.locs[,,which(dateVec == locDates[t])] <- L.light
} else if(errEll == TRUE){
#stop('Error: Error ellipse functionality is not yet available.')
# arithmetic converts from meters to degrees (transformation due to projection?)
slon.sd <- locs$Error.Semi.minor.axis[t] / 1000 / 111 #semi minor axis
L.light.lon <- dnorm(t(g1$X), locs$Longitude[t], slon.sd) # Longitude data
slat.sd <- locs$Error.Semi.major.axis[t] / 1000 / 111 #semi major axis
L.light.lat <- dnorm(t(g1$Y), locs$Latitude[t], slat.sd)
#image.plot(g$lon[1,],g$lat[,1],L.light.lat*L.light.lon)
#draw.ellipse(-80,35,a=10,b=8)
#L.lat <- flip(raster(t(L.light.lat), xmn=min(lon),
#            xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction='y')
#plot(L.lat)
#L.lon <- flip(raster(t(L.light.lon), xmn=min(lon),
#                xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction = 'y')
#plot(L.lon)
L <- flip(raster(t(L.light.lat * L.light.lon), xmn=min(lon1),
xmx=max(lon1),ymn=min(lat1),ymx=max(lat1)), direction = 'y')
# offset
# Lext <- extent(xmin(L)-, xmax(L)+10, ymin(L)-10, ymax(L)+10)
#L1 <- raster(NA, extent=Lext)
shiftDist <- (-1 * (locs$Offset[t] / 1000 / 111))
if(shiftDist >= -10){
Ls <- shift(L, y = shiftDist)
#plot(L.new * Ls)
#L.new <- L
#L.new[L.new>=0] = 1
L.ext <- flip(raster(g$lon, xmn=min(lon),
xmx=max(lon),ymn=min(lat),ymx=max(lat)), direction = 'y')
L.ext[L.ext<=0] = 1
#Lsx <- extend(Ls, Lext)
Lsx <- crop(Ls, L.ext)
#Lsx <- raster(matrix(extract(Ls, Lext), nrow=nrow(L), ncol=ncol(L)), xmn=min(lon),
#              xmx=max(lon),ymn=min(lat),ymx=max(lat))
# rotate?
#Lsx <- rotateProj(Lsx, locs$Error.Ellipse.orientation[t])
#xres <- lon[2] - lon[1]; yres <- lat[2] - lat[1]
#locs$Offset[t] / 1000 / 111 # offset in degrees
rr <- resample(Lsx, L.ext)
#image.plot(lon,lat,t(as.matrix(flip(rr,direction='y'))))
L.locs[,,which(dateVec == locDates[t])] <- t(as.matrix(flip(rr,direction='y')))
} else{
# if supposed shift in error ellipse is >10 degrees, we revert to longitude only
slon.sd <- 35/111 # Converting from kms to degrees
L.light <- dnorm(t(g$lon), locs$Longitude[t], slon.sd)
L.locs[,,which(dateVec == locDates[t])] <- L.light
}
}
} else{
stop('No data type for this days location.')
}
print(t)
image.plot(lon,lat,L.locs[,,which(dateVec == locDates[t])], main=paste(dateVec[which(dateVec==locDates[t])]))
}
# End location is known
elo <- which.min(abs(g$lon[1,]-iniloc$lon[2]))
ela <- which.min(abs(g$lat[,1]-iniloc$lat[2]))
L.locs[elo, ela, length(dateVec)] <- 1
if(raster){
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
list.locs <- list(x = g$lon[1,], y = g$lat[,1], z = L.locs)
ex <- extent(list.locs)
L.locs <- brick(list.locs$z, xmn=ex[1], xmx=ex[2], ymn=ex[3], ymx=ex[4], transpose=T, crs)
L.locs <- flip(L.locs, direction = 'y')
L.locs <- stack(L.locs)
}
print(class(L.locs))
return(L.locs)
}
L.locs <- calc.locs2(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
L.locs
dateVec %in% locs$Date
locs$Date %in% dateVec
head(locs$Date)
head(dateVec)
as.Date(locs$Date) %in% dateVec
dateVec %in% as.Date(locs$Date)
which(dateVec %in% as.Date(locs$Date))
pdf('light ellipses_Lydia.pdf',width=10,height=8)
idx <- which(dateVec %in% as.Date(locs$Date))
for(i in idx){
plot(L.locs[[i]])
}
dev.off()
pdf('light ellipses_Lydia.pdf',width=10,height=8)
idx <- which(dateVec %in% as.Date(locs$Date))
for(i in idx){
plot(L.locs[[i]], main=paste(dateVec[i]))
}
dev.off()
spot = read.csv('~/Documents/WHOI/RData/WhiteSharks/2013/121325/121325-SPOT.csv')
dts <- as.POSIXct(spot$Date, format=findDateFormat(spot$Date))
didx <- dts >= tag & dts <= pop
spot <- spot[didx,]
str(spot)
head(as.Date(dts))
as.Date(dts) %in% dateVec
dts[didx]
dts <- dts[didx]
as.Date(dts) %in% dateVec
dateVec %in% as.Date(dts)
i=idx[1]
dateVec[i]
dts
?rworldmap
library(rworldmap)
?"rworldmap"
detach('package:rworldmap', unload=T)
?grep
?"stats"
?match
?as.Date
?setup.grid
?meshgrid
devtools::load_all(".")
?meshgrid
meshgrid
?dnorm
?image.plot
?strftime
?sprintf
?download.file
?open.ncdf
?group_by
library(dplyr)
?group_by
?summarise
?focal
?integrate
?spatial_sync_raster
?locfit
?predict
?aperm
?as.cimg
?gausskern
?kern
kern
?convolve
?arot
library(magic)
?arot
reqd <- list('stats', 'raster','utils','ncdf','dplyr','locfit', 'imager','spatial.tools')
order(reqd)
reqd <- c('stats', 'raster','utils','ncdf','dplyr','locfit', 'imager','spatial.tools')
order(reqd)
reqd[order(reqd)]
