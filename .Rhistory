}
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
list.sst <- list(x = lon, y = lat, z = L.sst)
ex <- extent(list.sst)
L.sst <- brick(list.sst$z, xmn=ex[1], xmx=ex[2], ymn=ex[3], ymx=ex[4], transpose=T, crs)
L.sst <- flip(L.sst, direction = 'y')
# make L.sst match resolution/extent of g
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
ex <- extent(c(min(g$lon[1,]), max(g$lon[1,]), min(g$lat[,1]), max(g$lat[,1])))
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
rasMatch <- raster(ex, nrows=row, ncols=col, crs = crs)
L.sst <- spatial_sync_raster(L.sst, rasMatch)
if(raster == 'brick'){
s <- L.sst
} else if(raster == 'stack'){
s <- stack(L.sst)
} else if(raster == 'array'){
s <- raster::as.array(L.sst, transpose = T)
}
print(class(L.sst))
# return sst likelihood surfaces
return(L.sst)
}
str(sst)
L.sst <- calc.sst(sst, sst.dir = sst.dir, g, dateVec, raster = 'stack')
L.sst
x=system(‘ruby -e “puts 1+1″‘, intern=TRUE)
x=system('ruby -e "puts 1+1"', intern=T)
x
?dnorm
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
ptt <- 121325
iniloc <- data.frame(matrix(c(1, 3, 2013, 46.47683333, -45.5640,
31, 8, 2013, 30.92645, -39.6919), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
pdt <- extract.pdt(pdt)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
pdt <- extract.pdt(pdt)
str(pdt)
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
str(pdt)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
didx <- dts >= tag & dts <= pop
pdt <- pdt[didx,]
lon = c(-70, -15)
lat = c(20, 60)
ohc.dir <- paste('~/Documents/WHOI/RData/HYCOM/', ptt, '/',sep = '')
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
limits = c(lon, lat) # (min long, max long, min lat, max lat)
nc.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(nc.dir, limits, resolution = 'quarter')
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
dat = removePacific(dat, lat, lon)
str(dat)
image.plot(dat[,,1,1])
image.plot(lon,lat,dat[,,1,1])
ncdir <- '~/Documents/WHOI/RData/pdtMatch/WOA_25deg/woa13_deav_t01_04.nc'
sd.woa <- open.ncdf(ncdir)
ncdir
ncdir <- '~Documents/WHOI/RData/pdtMatch/WOA_25deg/woa13_deav_t01_04.nc'
sd.woa <- open.ncdf(ncdir)
ncdir <- '~/Documents/WHOI/RData/pdtMatch/WOA_25deg/woa13_decav_t01_04.nc'
sd.woa <- open.ncdf(ncdir)
sd.woa
sd.woa <- get.var.ncdf(sd.woa, 't_sd')
str(sd.woa)
str(dat)
image.plot(sd.woa[,,1])
extract.woa <- function(nc.dir, bbox, resolution, sdDir){
# Extract the desired temperature data from a global
# dataset derived from monthly gridded climatology data
# contained in the 2013 World Ocean Atlas
#' @param nc.dir is the directory to load the global nc file from; make sure it's
#'        the only .nc file in the given directory
#' @param bbox is a bounding box of form (long min, long max, lat min, lat max)
#' @param resolution indicates whether oceanographic data is gridded at 'quarter'
#'        or 'one' degree resolution
#' @return returnwoa is a list containing:
#'   DAT is an array of temperature data with dimensions (long, lat, depth, time)
#'   depth contains 57 standard depth levels by default and levels are defined
#'   in variable 'depth' contained here. time dimension covers the months of
#'   tag deployment as gathered from querying month data in variable 'pdt'
#'   LON/LAT are vectors of lon/lat bounds
# load global nc
ncfiles = dir(nc.dir, pattern = '.nc')
nc = open.ncdf(paste(nc.dir, ncfiles, sep = ''))
# retrieve var bounds from global nc
lon = get.var.ncdf(nc, 'Longitude')
lat = get.var.ncdf(nc, 'Latitude')
depth = get.var.ncdf(nc, 'Depth')
# set bounds for extracting data
xmin = which.min((bbox[1] - lon) ^ 2); xmax = which.min((bbox[2] - lon) ^ 2)
ymin = which.min((bbox[3] - lat) ^ 2); ymax = which.min((bbox[4] - lat) ^ 2)
if(resolution == 'quarter'){
xlen = 4*(bbox[2] - bbox[1]) # for quarter degree
ylen = 4*(bbox[4] - bbox[3])
} else if(resolution == 'one'){
xlen = bbox[2] - bbox[1] # for one degree
ylen = bbox[4] - bbox[3]
} else{
stop('Resolution of input oceanographic data not defined.')
}
# define time bounds using tag data
#month <- as.numeric(format(pdt$Date, format='%m'))
#tmin = min(month); tmax = max(month); tlen = tmax - tmin + 1
#if (tlen <= 1){
#  tlen = 2
#}
dat = get.var.ncdf(nc, 'temp', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
if(exists('sd.woa')){
sd.woa = get.var.ncdf(sdDir, 't_sd', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
}
returnWOA = list(dat = dat, sd.woa = sd.woa, lon = lon[xmin:xmax], lat = lat[ymin:ymax], depth = depth)
}
return.woa = extract.woa(nc.dir, limits, resolution = 'quarter',sd.woa)
sdDir <- open.ncdf(ncdir)
return.woa = extract.woa(nc.dir, limits, resolution = 'quarter',sdDir)
extract.woa <- function(nc.dir, bbox, resolution, sdDir){
# Extract the desired temperature data from a global
# dataset derived from monthly gridded climatology data
# contained in the 2013 World Ocean Atlas
#' @param nc.dir is the directory to load the global nc file from; make sure it's
#'        the only .nc file in the given directory
#' @param bbox is a bounding box of form (long min, long max, lat min, lat max)
#' @param resolution indicates whether oceanographic data is gridded at 'quarter'
#'        or 'one' degree resolution
#' @return returnwoa is a list containing:
#'   DAT is an array of temperature data with dimensions (long, lat, depth, time)
#'   depth contains 57 standard depth levels by default and levels are defined
#'   in variable 'depth' contained here. time dimension covers the months of
#'   tag deployment as gathered from querying month data in variable 'pdt'
#'   LON/LAT are vectors of lon/lat bounds
# load global nc
ncfiles = dir(nc.dir, pattern = '.nc')
nc = open.ncdf(paste(nc.dir, ncfiles, sep = ''))
# retrieve var bounds from global nc
lon = get.var.ncdf(nc, 'Longitude')
lat = get.var.ncdf(nc, 'Latitude')
depth = get.var.ncdf(nc, 'Depth')
# set bounds for extracting data
xmin = which.min((bbox[1] - lon) ^ 2); xmax = which.min((bbox[2] - lon) ^ 2)
ymin = which.min((bbox[3] - lat) ^ 2); ymax = which.min((bbox[4] - lat) ^ 2)
if(resolution == 'quarter'){
xlen = 4*(bbox[2] - bbox[1]) # for quarter degree
ylen = 4*(bbox[4] - bbox[3])
} else if(resolution == 'one'){
xlen = bbox[2] - bbox[1] # for one degree
ylen = bbox[4] - bbox[3]
} else{
stop('Resolution of input oceanographic data not defined.')
}
# define time bounds using tag data
#month <- as.numeric(format(pdt$Date, format='%m'))
#tmin = min(month); tmax = max(month); tlen = tmax - tmin + 1
#if (tlen <= 1){
#  tlen = 2
#}
dat = get.var.ncdf(nc, 'temp', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
print(c(xmin, ymin, 1, 1))
print(c(xlen + 1, ylen + 1, 57, 12))
if(exists('sd.woa')){
sd.woa = get.var.ncdf(sdDir, 't_sd', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
}
returnWOA = list(dat = dat, sd.woa = sd.woa, lon = lon[xmin:xmax], lat = lat[ymin:ymax], depth = depth)
}
return.woa = extract.woa(nc.dir, limits, resolution = 'quarter',sdDir)
extract.woa <- function(nc.dir, bbox, resolution, sdDir){
# Extract the desired temperature data from a global
# dataset derived from monthly gridded climatology data
# contained in the 2013 World Ocean Atlas
#' @param nc.dir is the directory to load the global nc file from; make sure it's
#'        the only .nc file in the given directory
#' @param bbox is a bounding box of form (long min, long max, lat min, lat max)
#' @param resolution indicates whether oceanographic data is gridded at 'quarter'
#'        or 'one' degree resolution
#' @return returnwoa is a list containing:
#'   DAT is an array of temperature data with dimensions (long, lat, depth, time)
#'   depth contains 57 standard depth levels by default and levels are defined
#'   in variable 'depth' contained here. time dimension covers the months of
#'   tag deployment as gathered from querying month data in variable 'pdt'
#'   LON/LAT are vectors of lon/lat bounds
# load global nc
ncfiles = dir(nc.dir, pattern = '.nc')
nc = open.ncdf(paste(nc.dir, ncfiles, sep = ''))
# retrieve var bounds from global nc
lon = get.var.ncdf(nc, 'Longitude')
lat = get.var.ncdf(nc, 'Latitude')
depth = get.var.ncdf(nc, 'Depth')
# set bounds for extracting data
xmin = which.min((bbox[1] - lon) ^ 2); xmax = which.min((bbox[2] - lon) ^ 2)
ymin = which.min((bbox[3] - lat) ^ 2); ymax = which.min((bbox[4] - lat) ^ 2)
if(resolution == 'quarter'){
xlen = 4*(bbox[2] - bbox[1]) # for quarter degree
ylen = 4*(bbox[4] - bbox[3])
} else if(resolution == 'one'){
xlen = bbox[2] - bbox[1] # for one degree
ylen = bbox[4] - bbox[3]
} else{
stop('Resolution of input oceanographic data not defined.')
}
# define time bounds using tag data
#month <- as.numeric(format(pdt$Date, format='%m'))
#tmin = min(month); tmax = max(month); tlen = tmax - tmin + 1
#if (tlen <= 1){
#  tlen = 2
#}
dat = get.var.ncdf(nc, 'temp', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
print(c(xmin, ymin, 1, 1))
print(c(xlen + 1, ylen + 1, 57, 12))
if(exists('sd.woa')){
sd.woa = get.var.ncdf(sdDir, 't_sd', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 1))
}
returnWOA = list(dat = dat, sd.woa = sd.woa, lon = lon[xmin:xmax], lat = lat[ymin:ymax], depth = depth)
}
return.woa = extract.woa(nc.dir, limits, resolution = 'quarter',sdDir)
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
sd.woa = return.woa$sd.woa
image.plot(lon,lat,sd.woa[,,1])
image.plot(lon,lat,dat[,,1])
image.plot(lon,lat,dat[,,1,1])
tryL <- dnorm(16,dat[,,1,1],sd.woa[,,1])
str(tryL)
image.plot(lon,lat,tryL)
?dnorm
tryL <- dnorm(x=16,mean=dat[,,1,1],sd=sd.woa[,,1])
image.plot(lon,lat,tryL)
image.plot(lon,lat,dat[,,1])
image.plot(lon,lat,dat[,,1,1])
tryL <- dnorm(x=dat[,,1,1],mean=16,sd=sd.woa[,,1])
image.plot(lon,lat,tryL)
library(locfit) # loess works too...
install.packages('locfit')
library(locfit) # loess works too...
data(ethanol, package="locfit")
fit <- locfit(NOx ~ E, data=ethanol)
fit
str(fit)
str(ethanol)
n = nrow(ethanol)
nd = seq(0.535, 1.232, length = 100)
pred = predict(fit, newdata=nd, se=T, get.data=T)
plot(fit, get.data=TRUE)
lines(nd, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(nd, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
?locfit
?predict
str(pred)
plot(fit)
plot(pred)
minT <- c(21.4,21.6,18.2,17.4,15.6,14.2,11.8,8.4)
maxT <- c(23,22.4,18.6,17.8,16.6,15.4,12.6,8.8)
deps <- c(0,64,320,456,576,640,752,952)
midT <- (maxT + minT) / 2
head(ethanol)
?ethanol
fit <- locfit(midT ~ deps)
fit
plot(fit)
plot(fit, get.data=TRUE)
n = nrow(deps)
n
n = length(deps)
n
ls()
depth
stdDepth <- depth
depIdx <- findInterval(deps, stdDepth) #locates climatology dep points nearest to tag's recorded depths
depIdx
woaDep <- stdDepth[depIdx]
woaDep
pred = predict(fit, newdata=woaDep, se=T, get.data=T)
str(pred)
plot(fit, get.data=TRUE)
lines(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
fit <- locfit(deps ~ midT)
n = length(deps)
depIdx <- findInterval(deps, stdDepth) #locates climatology dep points nearest to tag's recorded depths
woaDep <- stdDepth[depIdx]
#nd = seq(0.535, 1.232, length = 100)
pred = predict(fit, newdata=woaDep, se=T, get.data=T)
plot(fit, get.data=TRUE)
lines(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
woaDep
lines(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
head(pred)
fit <- locfit(midT ~ deps)
n = length(deps)
depIdx <- findInterval(deps, stdDepth) #locates climatology dep points nearest to tag's recorded depths
woaDep <- stdDepth[depIdx]
#nd = seq(0.535, 1.232, length = 100)
pred = predict(fit, newdata=woaDep, se=T, get.data=T)
plot(fit, get.data=TRUE)
lines(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
points(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2)
points(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2)
stdDepth
?predict
extract.woa <- function(nc.dir, bbox, resolution, sdDir){
# Extract the desired temperature data from a global
# dataset derived from monthly gridded climatology data
# contained in the 2013 World Ocean Atlas
#' @param nc.dir is the directory to load the global nc file from; make sure it's
#'        the only .nc file in the given directory
#' @param bbox is a bounding box of form (long min, long max, lat min, lat max)
#' @param resolution indicates whether oceanographic data is gridded at 'quarter'
#'        or 'one' degree resolution
#' @return returnwoa is a list containing:
#'   DAT is an array of temperature data with dimensions (long, lat, depth, time)
#'   depth contains 57 standard depth levels by default and levels are defined
#'   in variable 'depth' contained here. time dimension covers the months of
#'   tag deployment as gathered from querying month data in variable 'pdt'
#'   LON/LAT are vectors of lon/lat bounds
# load global nc
ncfiles = dir(nc.dir, pattern = '.nc')
nc = open.ncdf(paste(nc.dir, ncfiles, sep = ''))
# retrieve var bounds from global nc
lon = get.var.ncdf(nc, 'Longitude')
lat = get.var.ncdf(nc, 'Latitude')
depth = get.var.ncdf(nc, 'Depth')
# set bounds for extracting data
xmin = which.min((bbox[1] - lon) ^ 2); xmax = which.min((bbox[2] - lon) ^ 2)
ymin = which.min((bbox[3] - lat) ^ 2); ymax = which.min((bbox[4] - lat) ^ 2)
if(resolution == 'quarter'){
xlen = 4*(bbox[2] - bbox[1]) # for quarter degree
ylen = 4*(bbox[4] - bbox[3])
} else if(resolution == 'one'){
xlen = bbox[2] - bbox[1] # for one degree
ylen = bbox[4] - bbox[3]
} else{
stop('Resolution of input oceanographic data not defined.')
}
# define time bounds using tag data
#month <- as.numeric(format(pdt$Date, format='%m'))
#tmin = min(month); tmax = max(month); tlen = tmax - tmin + 1
#if (tlen <= 1){
#  tlen = 2
#}
dat = get.var.ncdf(nc, 'temp', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
print(c(xmin, ymin, 1, 1))
print(c(xlen + 1, ylen + 1, 57, 12))
if(exists('sd.woa')){
sd.woa = get.var.ncdf(sdDir, 't_sd', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 1))
}
returnWOA = list(dat = dat, sd.woa = sd.woa, lon = lon[xmin:xmax], lat = lat[ymin:ymax], depth = depth)
}
ls()
str(dat)
sst <- dat[,,1,3]
woa1 = matrix(1:100/3, 10,10)
woa2 = matrix(1:100/3,10,10)
woa = rbind(woa1[1:5,],woa2[1:5,])
image.plot(woa,xlab='fake longitude',ylab='fake latitude', main='ocean temperature surface')
plot(fit, get.data=TRUE)
# and add SE based on model predictions at new depth levels
lines(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
str(woa)
stdDepth
?round
round(stdDepth)
std <- c(0.0,2.5,7.5, 12.5, 17.5, 22.5, 27.5, 32.5, 37.5, 42.5, 47.5, 52.5, 57.5,
62.5, 67.5, 72.5, 77.5, 82.5, 87.5, 92.5, 97.5,112.5,137.5,162.5,187.5,212.5,
237.5,262.5,287.5,312.5,337.5,362.5,387.5,412.5,437.5,462.5,487.5,525.0,575.0,
625.0,675.0,725.0,775.0,825.0,875.0,925.0,975.0, 1025.0, 1075.0, 1125.0, 1175.0, 1225.0,
1275.0, 1325.0, 1375.0, 1425.0, 1475.0)
minT <- c(21.4,21.6,18.2,17.4,15.6,14.2,11.8,8.4)
maxT <- c(23,22.4,18.6,17.8,16.6,15.4,12.6,8.8)
deps <- c(0,64,320,456,576,640,752,952)
midT <- (maxT + minT) / 2
stdDepth <- c(0.0,2.5,7.5, 12.5, 17.5, 22.5, 27.5, 32.5, 37.5, 42.5, 47.5, 52.5, 57.5,
62.5, 67.5, 72.5, 77.5, 82.5, 87.5, 92.5, 97.5,112.5,137.5,162.5,187.5,212.5,
237.5,262.5,287.5,312.5,337.5,362.5,387.5,412.5,437.5,462.5,487.5,525.0,575.0,
625.0,675.0,725.0,775.0,825.0,875.0,925.0,975.0, 1025.0, 1075.0, 1125.0, 1175.0,
1225.0, 1275.0, 1325.0, 1375.0, 1425.0, 1475.0)
# do the regression
?locfit
fit <- locfit(midT ~ deps)
n = length(deps)
# find the standard depth levels that correspond to the depths the tag data is measured at
depIdx <- findInterval(deps, stdDepth)
woaDep <- stdDepth[depIdx]
# make predictions based on the regression model earlier for the temperature at standard WOA depth levels
pred = predict(fit, newdata=woaDep, se=T, get.data=T)
# see the regression
plot(fit, get.data=TRUE)
# and add SE based on model predictions at new depth levels
lines(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
#points(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2)
#points(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2)
# fake temperature surface
woa1 = matrix(1:100/3, 10,10)
woa2 = matrix(1:100/3,10,10)
woa = rbind(woa1[1:5,],woa2[1:5,])
image.plot(woa,xlab='fake longitude',ylab='fake latitude', main='ocean temperature surface')
str(pred)
pred
fit
print(fit)
summary(fit)
str(fit)
cbind(woaDep,pred$fit-pred$se.fit*sqrt(n),pred$fit+pred$se.fit*sqrt(n))
cbind(woaDep,pred$fit,pred$fit-pred$se.fit*sqrt(n),pred$fit+pred$se.fit*sqrt(n))
cbind(woaDep,fitT=pred$fit,sd_lwr=pred$fit-pred$se.fit*sqrt(n),sd_upr=pred$fit+pred$se.fit*sqrt(n))
9+26+45+1+25+1+19+18
devtools::load_all(".")
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
data("countriesLow")
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
plot(L.locs[[4]])
plot(countriesLow, add = T)
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
limits
lon = c(-90, -40)
lat = c(10, 55)
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat;
lon = as.numeric(return.woa$lon);
lat = as.numeric(return.woa$lat);
depth = as.numeric(return.woa$depth)
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
extract.woa
extract.woa <- function(nc.dir, bbox, resolution){
# Extract the desired temperature data from a global
# dataset derived from monthly gridded climatology data
# contained in the 2013 World Ocean Atlas
#' @param nc.dir is the directory to load the global nc file from; make sure it's
#'        the only .nc file in the given directory
#' @param bbox is a bounding box of form (long min, long max, lat min, lat max)
#' @param resolution indicates whether oceanographic data is gridded at 'quarter'
#'        or 'one' degree resolution
#' @return returnwoa is a list containing:
#'   DAT is an array of temperature data with dimensions (long, lat, depth, time)
#'   depth contains 57 standard depth levels by default and levels are defined
#'   in variable 'depth' contained here. time dimension covers the months of
#'   tag deployment as gathered from querying month data in variable 'pdt'
#'   LON/LAT are vectors of lon/lat bounds
# load global nc
ncfiles = dir(nc.dir, pattern = '.nc')
nc = open.ncdf(paste(nc.dir, ncfiles, sep = ''))
# retrieve var bounds from global nc
lon = get.var.ncdf(nc, 'Longitude')
lat = get.var.ncdf(nc, 'Latitude')
depth = get.var.ncdf(nc, 'Depth')
# set bounds for extracting data
xmin = which.min((bbox[1] - lon) ^ 2); xmax = which.min((bbox[2] - lon) ^ 2)
ymin = which.min((bbox[3] - lat) ^ 2); ymax = which.min((bbox[4] - lat) ^ 2)
if(resolution == 'quarter'){
xlen = 4*(bbox[2] - bbox[1]) # for quarter degree
ylen = 4*(bbox[4] - bbox[3])
} else if(resolution == 'one'){
xlen = bbox[2] - bbox[1] # for one degree
ylen = bbox[4] - bbox[3]
} else{
stop('Resolution of input oceanographic data not defined.')
}
# define time bounds using tag data
#month <- as.numeric(format(pdt$Date, format='%m'))
#tmin = min(month); tmax = max(month); tlen = tmax - tmin + 1
#if (tlen <= 1){
#  tlen = 2
#}
dat = get.var.ncdf(nc, 'temp', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
returnWOA = list(dat = dat, lon = lon[xmin:xmax], lat = lat[ymin:ymax], depth = depth)
}
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat;
lon = as.numeric(return.woa$lon);
lat = as.numeric(return.woa$lat);
depth = as.numeric(return.woa$depth)
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
# check woa data
graphics.off()
image.plot(lon,lat,dat[,,1,1])
