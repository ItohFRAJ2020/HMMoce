sdx <- .7
for (b in 1:length(depIdx)){
# sequence
dt = seq(df$low[b], df$high[b], length=10)
# likelihood array for one depth
lik0 = aaply(dt, 1, .fun = function(z) dnorm(x[b], dat[,,depIdx[b],pdtMonth], sdx))
lik.b.int = apply(lik0, 2:3, sum)
# calculate likelihood at each depth for a given tag time point
#lik.b <- dnorm(dat[,, b, pdtMonth], tag$x[which(depIdx == b)], sdx)
#lik.b <- (lik.b / max(lik.b, na.rm = T)) - .05
if(b == 1){
lik.pdt <- as.array(lik.b.int)
} else{
lik.pdt <- abind(lik.pdt, lik.b.int, along = 3)
}
}
lik.pdt <- apply(lik.pdt, 1:2, prod)
idx <- which(dateVec == as.Date(time))
L.pdt[,,idx] = lik.pdt
print(time)
} else{
# what to do if y<3?
}
}
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
list.pdt <- list(x = lon, y = lat, z = L.pdt)
ex <- extent(list.pdt)
L.pdt <- brick(list.pdt$z, xmn=ex[1], xmx=ex[2], ymn=ex[3], ymx=ex[4], transpose=T, crs)
L.pdt <- flip(L.pdt, direction = 'y')
# make L.pdt match resolution/extent of g
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
ex <- extent(c(min(g$lon[1,]), max(g$lon[1,]), min(g$lat[,1]), max(g$lat[,1])))
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
rasMatch <- raster(ex, nrows=row, ncols=col, crs = crs)
L.pdt <- spatial_sync_raster(L.pdt, rasMatch)
if(raster == 'brick'){
s <- L.pdt
} else if(raster == 'stack'){
s <- stack(L.pdt)
} else if(raster == 'array'){
s <- raster::as.array(L.pdt, transpose = T)
}
print(class(s))
return(s)
}
dat = return.woa$dat;
lon = as.numeric(return.woa$lon);
lat = as.numeric(return.woa$lat);
depth = as.numeric(return.woa$depth)
L.pdt <- calc.pdt(pdt, dat, lat, lon, g, depth, raster = 'stack', dateVec = dateVec)
plot(L.pdt[[2]])
plot(countriesLow, add = T)
b
plot(L.pdt[[1]])
plot(L.pdt[[2]])
plot(countriesLow, add = T)
plot(L.pdt[[3]])
plot(countriesLow, add = T)
plot(L.pdt[[30]])
plot(countriesLow, add = T)
?locfit
library(locfit)
?locfit
?predict
library(fields)
library(plyr)
# this is real data
minT <- c(21.4,21.6,18.2,17.4,15.6,14.2,11.8,8.4)
maxT <- c(23,22.4,18.6,17.8,16.6,15.4,12.6,8.8)
deps <- c(0,64,320,456,576,640,752,952)
midT <- (maxT + minT) / 2
stdDepth <- c(0.0,2.5,7.5, 12.5, 17.5, 22.5, 27.5, 32.5, 37.5, 42.5, 47.5, 52.5, 57.5,
62.5, 67.5, 72.5, 77.5, 82.5, 87.5, 92.5, 97.5,112.5,137.5,162.5,187.5,212.5,
237.5,262.5,287.5,312.5,337.5,362.5,387.5,412.5,437.5,462.5,487.5,525.0,575.0,
625.0,675.0,725.0,775.0,825.0,875.0,925.0,975.0, 1025.0, 1075.0, 1125.0, 1175.0,
1225.0, 1275.0, 1325.0, 1375.0, 1425.0, 1475.0)
# do the regression
fit <- locfit(midT ~ deps)
fit
?dnorm
dnorm(1)
dnorm(1:10)
plot(dnorm(1:10))
plot(dnorm(seq(0,1,by=10)))
plot(dnorm(seq(0,1,length.out=10)))
plot(dnorm(seq(-1,1,length.out=10)))
dnorm(seq(-1,1,length.out=10))
?dnorm
plot(dnorm(seq(-1,1,length.out=10),.5))
?dnorm
plot(dnorm(seq(-1,1,length.out=10),sd=.5))
dt
dt = seq(df1[1,1], df1[1,2], length=10)
library(locfit)
library(fields)
library(plyr)
# this is real data
minT <- c(21.4,21.6,18.2,17.4,15.6,14.2,11.8,8.4)
maxT <- c(23,22.4,18.6,17.8,16.6,15.4,12.6,8.8)
deps <- c(0,64,320,456,576,640,752,952)
midT <- (maxT + minT) / 2
stdDepth <- c(0.0,2.5,7.5, 12.5, 17.5, 22.5, 27.5, 32.5, 37.5, 42.5, 47.5, 52.5, 57.5,
62.5, 67.5, 72.5, 77.5, 82.5, 87.5, 92.5, 97.5,112.5,137.5,162.5,187.5,212.5,
237.5,262.5,287.5,312.5,337.5,362.5,387.5,412.5,437.5,462.5,487.5,525.0,575.0,
625.0,675.0,725.0,775.0,825.0,875.0,925.0,975.0, 1025.0, 1075.0, 1125.0, 1175.0,
1225.0, 1275.0, 1325.0, 1375.0, 1425.0, 1475.0)
# do the regression
fit <- locfit(midT ~ deps)
n = length(deps)
# find the standard depth levels that correspond to the depths the tag data is measured at
depIdx <- findInterval(deps, stdDepth)
woaDep <- stdDepth[depIdx]
# make predictions based on the regression model earlier for the temperature at standard WOA depth levels
pred = predict(fit, newdata=woaDep, se=T, get.data=T)
# see the regression
plot(fit, get.data=TRUE)
# and add SE based on model predictions at new depth levels
lines(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
#points(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2)
#points(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2)
# fake temperature surface
woa1 = matrix(1:100/3, 10,10)
woa2 = matrix(1:100/3,10,10)
woa = rbind(woa1[1:5,],woa2[1:5,])
image.plot(woa1,xlab='fake longitude',ylab='fake latitude', main='ocean temperature surface')
df = data.frame(low=pred.low$fit[depIdx]-pred.low$se.fit[depIdx]*sqrt(n), high=pred.high$fit[depIdx]+pred.high$se.fit[depIdx]*sqrt(n), row.names = stdDepth[depIdx])
df1 <- data.frame(low=pred$fit[depIdx]-pred$se.fit[depIdx]*sqrt(n),
high=pred$fit[depIdx]+pred$se.fit[depIdx]*sqrt(n),
row.names = stdDepth[depIdx])
library(locfit)
library(fields)
library(plyr)
# this is real data
minT <- c(21.4,21.6,18.2,17.4,15.6,14.2,11.8,8.4)
maxT <- c(23,22.4,18.6,17.8,16.6,15.4,12.6,8.8)
deps <- c(0,64,320,456,576,640,752,952)
midT <- (maxT + minT) / 2
stdDepth <- c(0.0,2.5,7.5, 12.5, 17.5, 22.5, 27.5, 32.5, 37.5, 42.5, 47.5, 52.5, 57.5,
62.5, 67.5, 72.5, 77.5, 82.5, 87.5, 92.5, 97.5,112.5,137.5,162.5,187.5,212.5,
237.5,262.5,287.5,312.5,337.5,362.5,387.5,412.5,437.5,462.5,487.5,525.0,575.0,
625.0,675.0,725.0,775.0,825.0,875.0,925.0,975.0, 1025.0, 1075.0, 1125.0, 1175.0,
1225.0, 1275.0, 1325.0, 1375.0, 1425.0, 1475.0)
# do the regression
fit <- locfit(midT ~ deps)
n = length(deps)
# find the standard depth levels that correspond to the depths the tag data is measured at
depIdx <- findInterval(deps, stdDepth)
woaDep <- stdDepth[depIdx]
# make predictions based on the regression model earlier for the temperature at standard WOA depth levels
pred = predict(fit, newdata=woaDep, se=T, get.data=T)
# see the regression
plot(fit, get.data=TRUE)
# and add SE based on model predictions at new depth levels
lines(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
#points(woaDep, pred$fit+pred$se.fit*sqrt(n), col=2)
#points(woaDep, pred$fit-pred$se.fit*sqrt(n), col=2)
# fake temperature surface
woa1 = matrix(1:100/3, 10,10)
woa2 = matrix(1:100/3,10,10)
woa = rbind(woa1[1:5,],woa2[1:5,])
image.plot(woa1,xlab='fake longitude',ylab='fake latitude', main='ocean temperature surface')
# put everything in one spot
out <- cbind(woaDep,fitT=pred$fit,sd_lwr=pred$fit-pred$se.fit*sqrt(n),sd_upr=pred$fit+pred$se.fit*sqrt(n))
# ** now how do we implement LeBris's likelihood routine via integration from sd_lwr to sd_upr?
#-------------------------------------------------------------------------#
# like this!
#-------------------------------------------------------------------------#
# do the regression at min and max
fit.low <- locfit(minT ~ deps)
fit.high <- locfit(maxT ~ deps)
n = length(deps)
# find the standard depth levels that correspond to the depths the tag data is measured at
# depIdx <- findInterval(deps, stdDepth)
# use the which.min
depIdx = apply(as.data.frame(deps), 1, FUN=function(x) which.min((x-stdDepth)^2))
woaDep <- stdDepth[depIdx]
# make predictions based on the regression model earlier for the temperature at standard WOA depth levels for low and high temperature at that depth
pred = predict(fit, newdata=stdDepth, se=T, get.data=T)
pred.low = predict(fit.low, newdata=stdDepth, se=T, get.data=T)
pred.high = predict(fit.high, newdata=stdDepth, se=T, get.data=T)
plot(fit, get.data=TRUE, lwd=2)
# and add SE based on model predictions at new depth levels
lines(stdDepth, pred$fit+pred$se.fit*sqrt(n), col=2, lty=2)
lines(stdDepth, pred$fit-pred$se.fit*sqrt(n), col=2, lty=2)
lines(fit.low, col = 4, lwd=2)
lines(fit.high, col = 4, lwd=2)
lines(stdDepth, pred.high$fit+pred.high$se.fit*sqrt(n), col=4, lty=2)
lines(stdDepth, pred.low$fit-pred.low$se.fit*sqrt(n), col=4, lty=2)
n =length(stdDepth)
# data frame for next step
df = data.frame(low=pred.low$fit[depIdx]-pred.low$se.fit[depIdx]*sqrt(n), high=pred.high$fit[depIdx]+pred.high$se.fit[depIdx]*sqrt(n), row.names = stdDepth[depIdx])
df1 <- data.frame(low=pred$fit[depIdx]-pred$se.fit[depIdx]*sqrt(n),
high=pred$fit[depIdx]+pred$se.fit[depIdx]*sqrt(n),
row.names = stdDepth[depIdx])
#---------------------------------------------------------------------------------------#
woasd = .7
dt = seq(df1[1,1], df1[1,2], length=10)
# likelihood array for one depth
lik0 = aaply(dt, 1, .fun = function(x) dnorm(x, woa, .7))
str(lik0)
plot(dnorm(seq(-1,1,length.out=10),sd=.5))
plot(dnorm(seq(-1,1,length.out=10),sd=.5),type='l')
dnorm(seq(-1,1,length.out=10),sd=.5)
plot(dnorm(seq(-1,1,length.out=10),sd=.1),type='l')
plot(dnorm(seq(-1,1,length.out=10),sd=.5),type='l')
x = 22.7
sdx = .5
plot(function(x) dnorm(x,mean=18,sd=.2), 15, 20,main = "tag recorded temperature",
xlab='temperature (c)')
plot(function(x) dnorm(5000,mean=18,sd=.2), 15, 20,main = "tag recorded temperature",
xlab='temperature (c)')
dnorm(x,mean=18,sd=.2)
rm(x)
function(x) dnorm(x,mean=18,sd=.2)
plot(function(x) dnorm(x,mean=18,sd=.2), 15, 20,main = "tag recorded temperature",
xlab='temperature (c)')
plot(dnorm(seq(-1,1,length.out=10),sd=.5),type='l')
devtools::load_all(".")
data("countriesLow")
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
plot(L.locs[[4]])
plot(countriesLow, add = T)
plot(L.locs[[5]])
plot(countriesLow, add = T)
plot(L.locs[[30]])
plot(countriesLow, add = T)
plot(L.locs[[35]])
plot(countriesLow, add = T)
lon = c(-90, -40)
lat = c(10, 55)
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
# woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat;
lon = as.numeric(return.woa$lon);
lat = as.numeric(return.woa$lat);
depth = as.numeric(return.woa$depth)
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
graphics.off()
# check woa data
image.plot(lon,lat,dat[,,1,1])
extract.woa <- function(nc.dir, bbox, resolution){
# Extract the desired temperature data from a global
# dataset derived from monthly gridded climatology data
# contained in the 2013 World Ocean Atlas
#' @param nc.dir is the directory to load the global nc file from; make sure it's
#'        the only .nc file in the given directory
#' @param bbox is a bounding box of form (long min, long max, lat min, lat max)
#' @param resolution indicates whether oceanographic data is gridded at 'quarter'
#'        or 'one' degree resolution
#' @return returnwoa is a list containing:
#'   DAT is an array of temperature data with dimensions (long, lat, depth, time)
#'   depth contains 57 standard depth levels by default and levels are defined
#'   in variable 'depth' contained here. time dimension covers the months of
#'   tag deployment as gathered from querying month data in variable 'pdt'
#'   LON/LAT are vectors of lon/lat bounds
# load global nc
ncfiles = dir(nc.dir, pattern = '.nc')
nc = open.ncdf(paste(nc.dir, ncfiles, sep = ''))
# retrieve var bounds from global nc
lon = get.var.ncdf(nc, 'Longitude')
lat = get.var.ncdf(nc, 'Latitude')
depth = get.var.ncdf(nc, 'Depth')
# set bounds for extracting data
xmin = which.min((bbox[1] - lon) ^ 2); xmax = which.min((bbox[2] - lon) ^ 2)
ymin = which.min((bbox[3] - lat) ^ 2); ymax = which.min((bbox[4] - lat) ^ 2)
if(resolution == 'quarter'){
xlen = 4*(bbox[2] - bbox[1]) # for quarter degree
ylen = 4*(bbox[4] - bbox[3])
} else if(resolution == 'one'){
xlen = bbox[2] - bbox[1] # for one degree
ylen = bbox[4] - bbox[3]
} else{
stop('Resolution of input oceanographic data not defined.')
}
# define time bounds using tag data
#month <- as.numeric(format(pdt$Date, format='%m'))
#tmin = min(month); tmax = max(month); tlen = tmax - tmin + 1
#if (tlen <= 1){
#  tlen = 2
#}
dat = get.var.ncdf(nc, 'temp', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
returnWOA = list(dat = dat, lon = lon[xmin:xmax], lat = lat[ymin:ymax], depth = depth)
}
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat;
lon = as.numeric(return.woa$lon);
lat = as.numeric(return.woa$lat);
depth = as.numeric(return.woa$depth)
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
# check woa data
graphics.off()
image.plot(lon,lat,dat[,,1,1])
L.pdt <- calc.pdt(pdt, dat, lat, lon, g, depth, raster = 'stack', dateVec = dateVec)
library(locfit)
L.pdt <- calc.pdt(pdt, dat, lat, lon, g, depth, raster = 'stack', dateVec = dateVec)
?spatial_sync_raster
??spatial_sync_raster
library(spatial.tools)
L.pdt <- calc.pdt(pdt, dat, lat, lon, g, depth, raster = 'stack', dateVec = dateVec)
plot(L.pdt[[30]])
plot(countriesLow, add = T)
L.locs = as.array(L.locs)
L.pdt = as.array(L.pdt)
L.locs[is.na(L.locs)] = 0 # turn NA to 0
L.pdt[is.na(L.pdt)] = 0
# you're the king of apply(). it's so handy!
nalocidx = apply(L.locs,3, sum, na.rm=T)==0 # does sum of likelihood surface
# at each time point == 0?
napdtidx = apply(L.pdt,3, sum, na.rm=T)==0
naLidx = nalocidx+napdtidx # where both are zeros. These will be interpolted in the filter
dateIdx = naLidx==0 # may not need this but here for now..
Lmat = L.pdt*0
idx1 = naLidx==1
idx2 = naLidx==2
Lmat[,,idx1] = L.pdt[,,idx1]+L.locs[,,idx1] # when only 1 has data
Lmat[,,idx2] = L.pdt[,,idx2]*L.locs[,,idx2] # when both have data
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
list.pdt <- list(x = lon, y = lat, z = L.pdt)
ex <- extent(list.pdt)
T <- dim(Lmat)[3]
for(i in 1:T){
L.i <- raster(Lmat[,,i], xmn=ex[1], xmx=ex[2], ymn=ex[3], ymx=ex[4], crs)
if(i==1) L <- L.i else L <- stack(L, L.i)
}
L <- aperm(as.array(flip(L, direction = 'y')), c(3,2,1))
# check that it worked ok
#lon <- seq(ex[1], ex[2], length=dim(L)[2])
lon <- g$lon[1,]
lat <- g$lat[,1]
#lat <- seq(ex[3], ex[4], length=dim(L)[3])
image.plot(lon, lat, L[12,,])
plot(countriesLow,add=T)
image.plot(lon, lat, L[12,,],zlim=c(.1,max(L,na.rm=T)))
image.plot(lon, lat, L[12,,])
plot(countriesLow,add=T)
max(L,na.rm=T)
image.plot(lon, lat, L[12,,], zlim=c(.1,max(L[12,,],na.rm=T)))
plot(countriesLow,add=T)
image.plot(lon, lat, L[12,,], zlim=c(2000,max(L[12,,],na.rm=T)))
plot(countriesLow,add=T)
image.plot(lon, lat, L[12,,], zlim=c(2000,max(L[12,,],na.rm=T)))
plot(countriesLow,fill='grey',color=white,add=T)
plot(countriesLow,fill='grey',color='white',add=T)
plot(countriesLow,fill='grey',color='grey',add=T)
plot(countriesLow,color='grey',add=T)
image.plot(lon,lat,L.pdt[12,,])
image.plot(lon,lat,L.pdt[[12]])
str(L.pdt)
str(g)
image.plot(lon,lat,L.pdt[,,12])
str(L.pdt)
str(lon)
plot(L.pdt[,,12])
r <- raster(L.pdt)
library(raster)
r <- raster(L.pdt)
r <- as.raster(L.pdt)
countries <- readShapePoly('/Users/Cam/Documents/WHOI/RData/Countries/countries_dissolve.shp')
proj4string(countries)=CRS("+init=epsg:3395") #world mercator projection
library(maptools); library(maps); library(scales); library(ggplot2);
library(mapproj); library(gridExtra); library(raster); library(rgdal)
countries <- readShapePoly('/Users/Cam/Documents/WHOI/RData/Countries/countries_dissolve.shp')
proj4string(countries)=CRS("+init=epsg:3395") #world mercator projection
fcountries = fortify(countries)
setwd('~/Documents/WHOI/RData/BerkeleyMap/')
data = read.table('sharks.csv',header=T,sep=',',blank.lines.skip=F)
data = read.table('sharks.csv',header=T,sep=',',blank.lines.skip=F)
setwd('~/Documents/WHOI/RData/BerkeleyMap/')
data = read.table('sharks.csv',header=T,sep=',',blank.lines.skip=F)
str(data)
data = read.table('sharks.csv',header=T,sep=',',skip=2,blank.lines.skip=F)
str(data)
data = read.table('sharks.csv',header=T,sep=',',skip=4,blank.lines.skip=F)
str(data)
data = read.table('sharks.csv',header=T,sep=',',skip=5,blank.lines.skip=F)
str(data)
data = read.table('sharks.csv',header=T,sep=';',skip=5,blank.lines.skip=F)
data = read.table('sharks.csv',header=T,sep=';',skip=5,blank.lines.skip=T)
data = read.table('sharks.csv',header=F,sep=';',skip=5,blank.lines.skip=F)
str(data)
head(data)
devtools::load_all(".")
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
library(locfit)
data("countriesLow")
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
plot(L.locs[[4]])
plot(countriesLow, add = T)
lon = c(-90, -40)
lat = c(10, 55)
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
extract.woa <- function(nc.dir, bbox, resolution){
# Extract the desired temperature data from a global
# dataset derived from monthly gridded climatology data
# contained in the 2013 World Ocean Atlas
#' @param nc.dir is the directory to load the global nc file from; make sure it's
#'        the only .nc file in the given directory
#' @param bbox is a bounding box of form (long min, long max, lat min, lat max)
#' @param resolution indicates whether oceanographic data is gridded at 'quarter'
#'        or 'one' degree resolution
#' @return returnwoa is a list containing:
#'   DAT is an array of temperature data with dimensions (long, lat, depth, time)
#'   depth contains 57 standard depth levels by default and levels are defined
#'   in variable 'depth' contained here. time dimension covers the months of
#'   tag deployment as gathered from querying month data in variable 'pdt'
#'   LON/LAT are vectors of lon/lat bounds
# load global nc
ncfiles = dir(nc.dir, pattern = '.nc')
nc = open.ncdf(paste(nc.dir, ncfiles, sep = ''))
# retrieve var bounds from global nc
lon = get.var.ncdf(nc, 'Longitude')
lat = get.var.ncdf(nc, 'Latitude')
depth = get.var.ncdf(nc, 'Depth')
# set bounds for extracting data
xmin = which.min((bbox[1] - lon) ^ 2); xmax = which.min((bbox[2] - lon) ^ 2)
ymin = which.min((bbox[3] - lat) ^ 2); ymax = which.min((bbox[4] - lat) ^ 2)
if(resolution == 'quarter'){
xlen = 4*(bbox[2] - bbox[1]) # for quarter degree
ylen = 4*(bbox[4] - bbox[3])
} else if(resolution == 'one'){
xlen = bbox[2] - bbox[1] # for one degree
ylen = bbox[4] - bbox[3]
} else{
stop('Resolution of input oceanographic data not defined.')
}
# define time bounds using tag data
#month <- as.numeric(format(pdt$Date, format='%m'))
#tmin = min(month); tmax = max(month); tlen = tmax - tmin + 1
#if (tlen <= 1){
#  tlen = 2
#}
dat = get.var.ncdf(nc, 'temp', start = c(xmin, ymin, 1, 1), count = c(xlen + 1, ylen + 1, 57, 12))
returnWOA = list(dat = dat, lon = lon[xmin:xmax], lat = lat[ymin:ymax], depth = depth)
}
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat;
lon = as.numeric(return.woa$lon);
lat = as.numeric(return.woa$lat);
depth = as.numeric(return.woa$depth)
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
# check woa data
graphics.off()
image.plot(lon,lat,dat[,,1,1])
xvec <- seq(0,5,length=51)
yvec <- seq(0,5,length=51)
z <- outer(xvec,yvec,"*") ## "*" is default but you could specify
## any other _vectorized_ function of two
## arguments ...
contour(xvec,yvec,z,levels=5)
?spplot
?spsample
