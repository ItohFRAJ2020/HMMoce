k1r <- raster(K1, xmn=-1, xmx=1, ymn=-1, ymx=1)
rudf = as.data.frame(as(k1r, 'SpatialPointsDataFrame'))
rudf[,1] = rudf[,1]/max(rudf[,1])
iter <- seq(10,10010,by=100)
hvec <- rep(NA, length(iter))
for (n in iter){
#n = 10 # samples to draw
samp = rudf[sample(1:nrow(rudf), n, prob = rudf[,1], replace = T),2:3]
coordinates(samp) = ~x+y
sampud = kernelUD(samp)
# compare h values
hvec[which(iter == n)] <- sampud@h$h
#rbind(ud@h$h, sampud@h$h)
}
plot(hvec~iter,type='l',xlab='# iterations',ylab='bandwidth, h')
h <- esri_h(rudf)
K2
rudf
K1
plot(k1r)
rudf
par0=c(8.908,10.27,3,1,0.707,0.866) # from Pedersen 2011
K1 <- gausskern(par0[1], par0[2], muadv = 0) # normally we then convert this into an image
K1
k1r <- raster(K1, xmn=-1, xmx=1, ymn=-1, ymx=1)
plot(k1r)
rudf = as.data.frame(as(k1r, 'SpatialPointsDataFrame'))
rudf[,1] = rudf[,1]/max(rudf[,1])
h <- esri_h(rudf)
x=1:9
mu = c(mean(x), mean(x)) + muadv
mu = c(mean(x), mean(x)) #+ muadv
mu
calc_sdd
?calc_sdd
load('example_likelihood_raster.RData')
load('~/Documents/WHOI/Data/Blues/2015/141256/example_likelihood_raster.RData')
rudf = as.data.frame(as(r, 'SpatialPointsDataFrame'))
rudf[,1] = rudf[,1]/max(rudf[,1])
r.pts <- rasterToPoints(r, spatial=TRUE)
rdf <- as.data.frame(r.pts)
rdf[,1] <- rdf[,1] / max(rdf[,1], na.rm=T)
plot(r)
world(add=T)
str(rdf)
devtools::load_all(".")
h <- esri_h(rdf)
points(-63,40)
rdf1 <- rdf[which(rdf[,1] != 0),]
str(rdf1)
r1 <- raster(rdf1[,1], xmn=min(rdf1$x), xmx=max(rdf1$x), ymn=min(rdf1$y), ymx=max(rdf1$y))
?SpatialPoints
matrix(rdf1$x,rdf1$y)
matrix(rdf1$x,rdf1$y,ncol=2)
matrix(rdf1[,2:3],ncol=2)
str(rdf1)
as.matrix(rdf1[,2:3])
rdf.spdf <- SpatialPointsDataFrame(as.matrix(rdf1[,2:3]), data=rdf1[,1])
rdf.spdf <- SpatialPointsDataFrame(as.matrix(rdf1[,2:3]), data=rdf1)
plot(rdf.spdf)
?raster
D1 <- c(9,10); D2 <- c(3,1) # let's call these units grid cells
K1 <- gausskern(D1[1], D1[2], muadv = 0) # normally we then convert this into an image
K2 <- gausskern(D2[1], D2[2], muadv = 0) # normally we then convert this into an image
K1
image.plot(K1)
image.plot(K2)
K2
(0-D1[1]/2)
k1r <- raster(K1, xmn=(0-D1[1]/2), xmx=(0+D1[1]/2), ymn=(0-D1[1]/2), ymx=(0+D1[1]/2))
plot(k1r)
k1r
k2r <- raster(K2, xmn=(0-D2[1]/2), xmx=(0+D2[1]/2), ymn=(0-D2[1]/2), ymx=(0+D2[1]/2))
k2r
D1 <- c(9,10); D2 <- c(3,1) # let's call these units degrees, for now
K1 <- gausskern(D1[1], D1[2], muadv = 0) # normally we then convert this into an image
K2 <- gausskern(D2[1], D2[2], muadv = 0) # normally we then convert this into an image
k1r <- raster(K1, xmn=(0-D1[1]/2), xmx=(0+D1[1]/2), ymn=(0-D1[1]/2), ymx=(0+D1[1]/2))
k2r <- raster(K2, xmn=(0-D2[1]/2), xmx=(0+D2[1]/2), ymn=(0-D2[1]/2), ymx=(0+D2[1]/2))
# ADE bandwidth approach
rdf1 = as.data.frame(as(k1r, 'SpatialPointsDataFrame'))
rdf1[,1] = rdf1[,1]/max(rdf1[,1])
rdf2 = as.data.frame(as(k2r, 'SpatialPointsDataFrame'))
rdf2[,1] = rdf2[,1]/max(rdf2[,1])
iter <- seq(10,10010,by=100)
hvec1 <- rep(NA, length(iter))
hvec2 <- rep(NA, length(iter))
for (n in iter){
#n = 10 # samples to draw
samp = rdf1[sample(1:nrow(rdf1), n, prob = rdf1[,1], replace = T),2:3]
coordinates(samp) = ~x+y
sampud = kernelUD(samp)
# compare h values
hvec1[which(iter == n)] <- sampud@h$h
#rbind(ud@h$h, sampud@h$h)
samp = rdf2[sample(1:nrow(rdf2), n, prob = rdf2[,1], replace = T),2:3]
coordinates(samp) = ~x+y
sampud = kernelUD(samp)
hvec2[which(iter == n)] <- sampud@h$h
}
plot(hvec1~iter,type='l',xlab='# iterations',ylab='bandwidth, h')
lines(hvec2~iter, col='blue')
plot(hvec1~iter,type='l',xlab='# iterations',ylab='bandwidth, h', ylim=c(0,1.6))
lines(hvec2~iter, col='blue')
h1 <- esri_h(rdf1)
h2 <- esri_h(rdf2)
points(h1~1,pch=16)
points(h2~1, pch=16,col='blue')
plot(k1r)
k1r
area(k1r)
raster::area(k1r)
a<-raster::area(k1r)
a
plot(a)
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
k1r <- raster(K1, xmn=(0-D1[1]/2), xmx=(0+D1[1]/2), ymn=(0-D1[1]/2), ymx=(0+D1[1]/2),crs=crs)
k2r <- raster(K2, xmn=(0-D2[1]/2), xmx=(0+D2[1]/2), ymn=(0-D2[1]/2), ymx=(0+D2[1]/2),crs=crs)
k1r
a <- raster::area(k1r)
a
plot(a)
a_sum <- raster::cellStats(a, 'sum')
a_sum
sqrt(a_sum)
sqrt(12309)
sqrt(a_sum)/110
a1 <- sqrt(raster::cellStats(raster::area(k1r), 'sum')) / 111
a2 <- sqrt(raster::cellStats(raster::area(k2r), 'sum')) / 111
a1
a2
h1
h2
D1.new <- D1; D2.new <- D2
D1.new[1] <- sqrt(raster::cellStats(raster::area(k1r), 'sum')) / 111
D2.new[1] <- sqrt(raster::cellStats(raster::area(k2r), 'sum')) / 111
D1.new
D1
?calc_sdd
?convert.to.shapefile
rdf <- rdf1
str(rdf)
rdf1[,1] <- rdf1[,1] / max(rdf1[,1])
h1 <- esri_h(rdf1)
rdf2[,1] <- rdf2[,1] / max(rdf2[,1])
h2 <- esri_h(rdf2)
rdf <- rdf1
sdd <- calc_sdd(calccentre=TRUE, weighted=TRUE, weights=rdf[,1],
points=rdf[,c(2,3)], verbose=F)$SDD.radius
calc_sdd
?distances
h1
sdd <- calc_sdd(calccentre=TRUE, weighted=TRUE, weights=rdf[,1],
points=rdf[,c(2,3)], verbose=F)$SDD.radius
sdd
mc <- mean_centre(weighted=TRUE, weights=rdf[,1], points=rdf[,c(2,3)])
Dm <- median(distances(centre.xy = mc[,2:3], destmat = rdf[,c(2,3)]))
term2 <- sqrt(1 / log(2)) * Dm
n <- sum(weights)
sdd < term2
h <- .9 * sdd * n^(-0.2)
h
mc
Dm <- median(distances(centre.xy = mc[,2:3], destmat = rdf[,c(2,3)]))
Dm
distances(centre.xy = mc[,2:3], destmat = rdf[,c(2,3)])
d<-distances(centre.xy = mc[,2:3], destmat = rdf[,c(2,3)])
d
mc
rdf[,c(2,3)]
distances
destmat <- rdf[,c(2,3)]
centre.xy <- mc[,c(2,3)]
centre.xy
destmat
di <- sqrt((destmat[,1] - centre.xy[1])^2 + (destmat[,2] - centre.xy[2])^2)
di
(destmat[,1] - centre.xy[1])
destmat[,1]
as.numeric(mc)
distances(centre.xy = as.numeric(mc[,2:3]), destmat = rdf[,c(2,3)])
Dm <- median(distances(centre.xy = as.numeric(mc[,2:3]), destmat = rdf[,c(2,3)]))
Dm
median(distances(centre.xy = as.numeric(mc[,2:3]), destmat = rdf[,c(2,3)]))
term2 <- sqrt(1 / log(2)) * Dm
weights
n <- sum(rdf[,1])
n
sdd < term2
h <- .9 * sdd * n^(-0.2)
h
h <- .9 * term2 * n^(-0.2)
h
h <- .9 * sdd * n^(-0.2)
sdd <- calc_sdd(calccentre=TRUE, weighted=TRUE, weights=rdf[,1],
points=rdf[,c(2,3)], verbose=F)$SDD.radius
devtools::load_all(".")
sdd <- calc_sdd(calccentre=TRUE, weighted=TRUE, weights=rdf[,1],
points=rdf[,c(2,3)], verbose=F)$SDD.radius
# adapted from function of same name from aspace package
calc_sdd <- function (id = 1, centre.xy = NULL,
calccentre = TRUE, weighted = FALSE, weights = NULL, points = activities,
verbose = FALSE)
{
errorcode <- 1000
n <- dim(points)[1]
if (calccentre) {
if (length(centre.xy) == 2) {
errorcode <- 21
cat("\n\nWARNING: Invalid combination: calccentre=TRUE and centre.xy!=NULL")
cat("\nERROR CODE: ", errorcode, "\n\n", sep = "")
return("ERROR")
}
else {
if (weighted) {
wt.x <- points[, 1] * weights
wt.y <- points[, 2] * weights
WMC.x <- c(sum(wt.x)/sum(weights))
WMC.y <- c(sum(wt.y)/sum(weights))
centre.xy[1] <- WMC.x
centre.xy[2] <- WMC.y
}
else {
meanx <- sum(points[, 1])/n
meany <- sum(points[, 2])/n
centre.xy[1] <- meanx
centre.xy[2] <- meany
}
}
}
# strictly euclidean
dist <- distances(centre.xy, points)
if (length(dist) >= 3) {
if (weighted) {
SDD <- sqrt(sum((weights * dist^2)/((sum(weights)) - 2)))
}
else {
SDD <- sqrt(sum(dist^2/(length(dist) - 2)))
}
sddarea <- pi * SDD^2
B <- min(SDD, SDD)
A <- max(SDD, SDD)
d2 <- (A - B) * (A + B)
phi <- 2 * pi * seq(0, 1, len = 360)
sp <- sin(phi)
cp <- cos(phi)
r <- SDD * SDD/sqrt(B^2 + d2 * sp^2)
xy <- r * cbind(cp, sp)
al <- 0 * pi/180
ca <- cos(al)
sa <- sin(al)
coordsSDD <- xy %*% rbind(c(ca, sa), c(-sa, ca)) + cbind(rep(centre.xy[1],
360), rep(centre.xy[2], 360))
sddloc <- as.data.frame(cbind(id, coordsSDD))
colnames(sddloc) = c("id", "x", "y")
#write.table(sddloc, sep = ",", file = filename, col.names = FALSE)
assign("sddloc", sddloc, pos = 1)
r.SDD <- list(id = id, points = points, coordsSDD = coordsSDD,
SDD = SDD, calccentre = calccentre, weighted = weighted,
weights = weights, CENTRE.x = centre.xy[1], CENTRE.y = centre.xy[2],
SDD.area = sddarea)
assign("r.SDD", r.SDD, pos = 1)
result.sdd <- list(id = id, calccentre = calccentre,
weighted = weighted, CENTRE.x = centre.xy[1], CENTRE.y = centre.xy[2],
SDD.radius = SDD, SDD.area = sddarea)
#print(result.sdd)
result.sdd <- as.data.frame(result.sdd)
assign("sddatt", result.sdd, pos = 1)
}
else {
errorcode <- 25
if (verbose) {
cat("\n\nWARNING: Not enough values to compute SDD.")
cat("\nERROR CODE: ", errorcode, "\n\n", sep = "")
}
return("ERROR")
}
}
sdd <- calc_sdd(calccentre=TRUE, weighted=TRUE, weights=rdf[,1],
points=rdf[,c(2,3)], verbose=F)$SDD.radius
sdd
plot(k1r)
sdd <- calc_sdd(calccentre=TRUE, weighted=TRUE, weights=rdf2[,1],
points=rdf2[,c(2,3)], verbose=F)$SDD.radius
sdd
par(mfrow=c(1,2))
plot(k1r)
plot(k2r)
distances(centre.xy = as.numeric(mc[,2:3]), destmat = rdf[,c(2,3)])
hist(distances(centre.xy = as.numeric(mc[,2:3]), destmat = rdf[,c(2,3)]))
rdf[,1]
D1 <- c(9,10); D2 <- c(9,1) # let's call these units degrees, for now
K1 <- gausskern(D1[1], D1[2], muadv = 0) # normally we then convert this into an image
K2 <- gausskern(D2[1], D2[2], muadv = 0) # normally we then convert this into an image
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
k1r <- raster(K1, xmn=(0-D1[1]/2), xmx=(0+D1[1]/2), ymn=(0-D1[1]/2), ymx=(0+D1[1]/2),crs=crs)
k2r <- raster(K2, xmn=(0-D2[1]/2), xmx=(0+D2[1]/2), ymn=(0-D2[1]/2), ymx=(0+D2[1]/2),crs=crs)
graphics.off()
D1 <- c(9,10); D2 <- c(9,1) # let's call these units degrees, for now
K1 <- gausskern(D1[1], D1[2], muadv = 0) # normally we then convert this into an image
K2 <- gausskern(D2[1], D2[2], muadv = 0) # normally we then convert this into an image
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
k1r <- raster(K1, xmn=(0-D1[1]/2), xmx=(0+D1[1]/2), ymn=(0-D1[1]/2), ymx=(0+D1[1]/2),crs=crs)
k2r <- raster(K2, xmn=(0-D2[1]/2), xmx=(0+D2[1]/2), ymn=(0-D2[1]/2), ymx=(0+D2[1]/2),crs=crs)
par(mfrow=c(1,2))
plot(k1r)
plot(k2r)
plot(k1r); main='D1 <- c(9,10)'
plot(k2r); main='D1 <- c(9,1)'
plot(k1r); title('D1 <- c(9,10)')
plot(k2r); title('D1 <- c(9,1)')
make.kern <- function(D,g){
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
NN <- row*col # Size of generator
H <- matrix(0,NN,NN)
Jx <- D[1]
Jy <- D[2]
# Jump left and right (x-direction)
j = (row+1):NN
for(i in 1:(NN-row)){
H[i,j[i]] <- Jx # Jump right
H[j[i],i] <- Jx # Jump left
}
# Jump up and down (y-direction)
j = 2:NN;
for(i in 1:(NN-1)){
H[i,j[i]] <- Jy # Jump down
H[j[i],i] <- Jy # Jump up
}
# Take care of top of domain
top <- seq(row+1,NN,by=row)
H[top,top-1] <- 0
# Take care of bottom of domain
bot <- seq(row,NN-row,by=row)
H[bot,bot+1] <- 0
# Sum rows
H <- H + diag(-apply(H,1,sum))
Matrix(H,sparse=TRUE,forceCheck=TRUE)
}
## Uniformization is an efficient way to compute the matrix exponential for a generator matrix
## See Grassmann 1977 - Transient solutions in Markovian queueing systems
## somehow "solving" transition equation by computing exponential?
# ** how to do this with length(dt) > 1?
uniformization <- function(A,dt){
N <- dim(A)[1]
# Find the numerical largest rate
F <- -min(diag(A))
# Calculate number of iterations based expression in Grassmann 1977, eq 10
m <- ceiling(F*dt + 4*sqrt(F*dt) + 5)
# Insert warning if m>140 ??
#I <- spMatrix(N,N,i=1:N,j=1:N,rep(1,N))
I <- Diagonal(N)
#I <- diag(N)
P <- A/F + I # Create sub-stochastic matrix (eq 8)
S <- I
pt <- I
FPdt <- F*P*dt
for(i in 1:m){
S <- S %*% FPdt
fact <- exp(lgamma(i+1))
pt <- pt + S/fact
}
# Multiply by the constant
pt <- pt * exp(-F*dt)
pt
}
?setup.grid
k1r
r.pts <- rasterToPoints(k1r, spatial=TRUE)
coordinates(r.pts[,1])
r.pts <- rasterToPoints(k1r, spatial=TRUE)
locations <- data.frame(Longitude = coordinates(r.pts)[,1], Latitude = coordinates(r.pts)[,2])
g <- setup.grid(locations, res=1)
str(locations)
g <- setup.grid(locations, res='one')
dt <- 1
par0 <- c(9,10,9,1)
G1 <- make.kern(D1,g)
library(Matrix)
G1 <- make.kern(D1,g)
K1 <- uniformization(G1,dt)
G2 <- make.kern(D2,g)
K2 <- uniformization(G2,dt)
K1
K2
image.plot(K1)
str(K1)
g
summary(locations)
lo <- seq(-4,4,by=1)
la <- seq(-4,4,by=1)
g <- meshgrid(lo, la)
g
dlo <- lo[2] - lo[1]
dla <- la[2] - la[1]
g <- list(lon = g$X, lat = g$Y, dlo = dlo, dla = dla)
g
G1 <- make.kern(D1,g)
K1 <- uniformization(G1,dt)
G2 <- make.kern(D2,g)
K2 <- uniformization(G2,dt)
str(K1)
hmm.filter2
gausskern
x=1:9
mean(x)
muadv=0
mu = c(mean(x), mean(x)) + muadv
mu
h1
h1 <- esri_h(rdf1)
h2 <- esri_h(rdf2)
h1
h2
siz=9
sigma=10
x = 1:round(siz)
mu = c(mean(x), mean(x)) + muadv
fx = (matrix(exp((-0.5 * (x - mu[1]) / sigma) ^ 2)) / (sqrt(2 * pi) * sigma))
fx
x
mu
matrix(exp((-0.5 * (x - mu[1]) / sigma) ^ 2))
fx = (matrix(exp((-0.5 * (x - mu[1]) / sigma) ^ 2)) / (sqrt(2 * pi) * sigma))
fx
fx1 = exp(-.5 * ((x - mu[1]) / sigma) ^ 2) / sqrt((2 * pi) * sigma)
fx1
fx1 = exp(.5 * ((x - mu[1]) / sigma)) / sqrt((2 * pi) * sigma)
fy1 = exp(.5 * ((x - mu[2]) / sigma)) / sqrt((2 * pi) * sigma)
fx = exp(.5 * ((x - mu[1]) / sigma)) / sqrt((2 * pi) * sigma)
fy = exp(.5 * ((x - mu[2]) / sigma)) / sqrt((2 * pi) * sigma)
sigma
plot(k1r)
title('bens')
plot(k1r)
plot(k1r)
title('gausskern')
fx = exp(.5 * ((x - mu[1]) / sigma)) / sqrt((2 * pi) * sigma)
fy = exp(.5 * ((x - mu[2]) / sigma)) / sqrt((2 * pi) * sigma)
fx[!is.finite(fx)] = 0
fy[!is.finite(fy)] = 0
kern = (fx %*% t(fy))
kern = kern / (sum(sum(kern, na.rm = T), na.rm = T))
kern[is.nan(kern)] = 0
kern
K3 <- kern
D2
D1
siz
sigma
k3r <- raster(K3, xmn=(0-D1[1]/2), xmx=(0+D1[1]/2), ymn=(0-D1[1]/2), ymx=(0+D1[1]/2),crs=crs)
plot(k3r)
title('bens')
rd = rnorm(1000,10,2)
plot(rd)
plot(density(rd))
plot(density(rd, bw = sd(rd)))
rug(rd)
?rnorm
rd = rnorm(1000,10,2)
plot(rd)
plot(density(rd))
lines(density(rd, bw = sd(rd)), col = 2)
rug(rd)
sd(rd)
plot(density(rd, bw = sd(rd)), col = 2)
str(rd)
plot(rd)
plot(density(rd))
sdd
rdf1[,1] <- rdf1[,1] / max(rdf1[,1])
h1 <- esri_h(rdf1)
h1
sdd <- calc_sdd(calccentre=TRUE, weighted=TRUE, weights=rdf1[,1],
points=rdf1[,c(2,3)], verbose=F)$SDD.radius
sdd
str(rd)
plot(density(rdf))
plot(density(rdf[,1]))
lines(density(rdf[,1], bw = sd(rd)), col = 2)
plot(density(rdf[,1], bw = sd(rd)), col = 2)
lines(density(rdf[,1]))
rug(rdf[,1])
?rug
plot(density(rdf[,1]))
lines(density(rdf[,1], bw = sd(rd)), col = 2)
plot(density(rdf[,1]))
rug(rdf[,1])
?density
?raster::density
plot(k1r)
plot(raster::density(k1r))
density(k1r,plot=F)
k1r
summary(rdf1)
?as.raster
?raster
plot(k1r)
fx = exp(-.5 * ((x - mu[1]) / sigma) ^ 2) / sqrt((2 * pi) * sigma)
fy = exp(-.5 * ((x - mu[2]) / sigma) ^ 2) / sqrt((2 * pi) * sigma)
fx
fy
t(fy)
graphics.off()
plot(k1r)
kern = (fx %*% t(fy))
kern
sum(kern, na.rm = T)
kern = kern / (sum(sum(kern, na.rm = T), na.rm = T))
sum(kern)
kern
