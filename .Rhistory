s
plot(s[[1]])
plot(countriesLow,add=TRUE)
s <- stack(L.locs[[1]], s, L.locs[[T]])
s <- stack(L.locs[[1]], s)
tagL <- spatial_sync_raster(L.locs[[1]], s)
s <- stack(tagL, s)
for(i in 2:(T-1)){
r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
# add known tag/pop locations
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
s
plot(s[[1]])
plot(countriesLow,add=TRUE)
plot(s[[T]])
plot(countriesLow,add=TRUE)
plot(s[[15]])
plot(s[[20]])
plot(countriesLow,add=TRUE)
dateIdx <- unique(c(which(dateVec %in% as.Date(pdt$Date)), c(1,which(dateVec %in% as.Date(locs$Date)),T)))
dateIdx
dateIdx <- sort(unique(c(which(dateVec %in% as.Date(pdt$Date)), c(1,which(dateVec %in% as.Date(locs$Date)),T))))
dateIdx
s.sub <- subset(s, dateIdx)
s.sub
plot(s.sub[[1]])
plot(s.sub[[2]])
plot(s.sub[[3]])
which(dateVec %in% as.Date(pdt$Date)
)
plot(L.locs[[3]])
dateVec[3]
as.Date(pdt$Date)
dateVec[3]
head(pdt)
pdt[1:20,]
pdt$MidTemp <- (pdt$MaxTemp + pdt$MinTemp) / 2
udates <- unique(pdt$Date)
i=3
time <- udates[i]
pdt.i <- pdt[which(pdt$Date == time),]
y <- pdt.i$Depth[!is.na(pdt.i$Depth)] #extracts depth from tag data for day i
y[y<0] <- 0
y
pdt.i
x <- pdt.i$MidTemp[!is.na(pdt.i$Depth)]  #extract temperature from tag data for day i
pdtMonth <- as.numeric(format(as.Date(pdt.i$Date), format='%m'))[1]
dat.i = dat[,,,pdtMonth] #extract months climatology
depIdx <- findInterval(y, depth) #locates climatology dep points nearest to tag's recorded depths
datDep = depth[depIdx]
tag = approx(y, x, xout=datDep, rule=2) #interpolates temperatures in y to relevant WOA depths
names(tag) = list('y', 'x')
tag
for (b in depIdx){
# calculate likelihood at each depth for a given tag time point
lik.b <- dnorm(dat[,, b, pdtMonth], tag$x[which(depIdx == b)], .5)
#lik.b <- (lik.b / max(lik.b, na.rm = T)) - .05
if(min(which(depIdx == b)) == 1){
lik.pdt <- as.array(lik.b)
} else{
lik.pdt <- abind(lik.pdt, lik.b, along = 3)
}
}
lik.pdt <- apply(lik.pdt, 1:2, prod)
image.plot(lik.pdt)
idx <- which(dateVec == as.Date(time))
idx
plot(L.pdt[[3]])
plot(L.locs[[3]])
ras <- L.pdt[[3]] * L.locs[[3]]
plot(ras)
plot(L.locs[[3]])
plot(L.pdt[[3]])
'NA' * 3
NA * 3
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
# calculate light-based likelihood
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
didx <- dts >= tag & dts <= pop
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
##
# OHC / HYCOM
##
## LET'S IGNORE HYCOM / OHC FOR NOW. CURRENTLY LYDIA'S TIMESPAN ISN'T
## AVAILABLE IN THE UNIFORM SPATIAL PROJECTION. THIS ISN'T A HUGE
## ISSUE AS I'VE MANAGED TO DEAL WITH THAT BUT I'D RATHER GET
## THIS TO YOU NOW AND JUST USE WOA. ONCE THE REST OF THE ROUTINE
## IS WORKING, OHC IS PIECE OF CAKE TO DROP IN.
ohc = FALSE
if (ohc){
ohc.dir <- paste('~/Documents/WHOI/RData/HYCOM/', ptt, '/',sep = '')
for(i in 1:length(udates)){
time <- as.Date(udates[i])
repeat{
get.hycom(lon,lat,time,filename=paste(ptt,'_-',time,'.nc',sep=''),download.file=TRUE,dir=ohc.dir, vars = 'water_temp') # filenames based on dates from above
#err <- try(open.ncdf(paste(ohc.dir,ptt,'_',time,'.nc',sep='')),silent=T)
tryCatch({
err <- try(open.ncdf(paste(ohc.dir,ptt,'_',time,'.nc',sep='')),silent=T)
}, error=function(e){print(paste('ERROR: Download of data at ',time,' failed. Trying call to server again.',sep=''))})
if(class(err) != 'try-error') break
}
}
# calc.ohc
L.ohc <- calc.ohc(pdt, ohc.dir = ohc.dir)
plot.ohc(lik = L.ohc, ohc.dir = ohcdir, pdt = pdt.data,
filename = paste(ptt,'_ohclik.pdf', sep = ''), write.dir = getwd())
}
##
# PDT / WOA
##
# set limits of interest
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
# check woa data
graphics.off()
image.plot(lon,lat,dat[,,1,1])
# perform matching
# 'stack' makes the end of this routine much slower than 'brick' or 'array'
# but is only 10 extra seconds or so
L.pdt <- calc.pdt(pdt, dat, lat, lon, raster = 'stack', dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
data(countriesLow)
plot(L.pdt[[100]])
plot(countriesLow, add = T)
plot = FALSE
if(plot){
plot.woa(as.array(L.pdt), return.woa, paste(ptt, '_woalik.pdf', sep=''), pdt = pdt, write.dir = getwd())
}
##
# Light-based Longitude Likelihood (ellipse error is a work in progress)
##
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > tag & dts < pop
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = 'stack', dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
plot(L.locs[[2]])
plot(countriesLow, add = T)
L.pdt <- spatial_sync_raster(L.pdt, L.locs)
plot(L.pdt[[4]])
plot(countriesLow, add = T)
# multiply daily likelihood matrices
T <- dim(L.pdt)[3]
for(i in 2:(T-1)){
r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
# add known tag/pop locations
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
# cut out days for which no pdt/loc data exists
dateIdx <- sort(unique(c(which(dateVec %in% as.Date(pdt$Date)), c(1,which(dateVec %in% as.Date(locs$Date)),T))))
s.sub <- subset(s, dateIdx)
s.sub
plot(s.sub[[1]])
plot(countriesLow,add=TRUE)
plot(s.sub[[2]])
plot(countriesLow,add=TRUE)
plot(s.sub[[3]])
plot(countriesLow,add=TRUE)
NaN * 3
any(s.sub[[3]] != 0)
any(matrix(s.sub[[3]]) != 0)
any(as.matrix(s.sub[[3]]) != 0)
s.sub[[3]]
any(!is.na(s.sub[[3]]))# != 0)
any(!is.na(as.matrix(s.sub[[3]])))# != 0)
any(!is.na(as.matrix(s.sub[[2]])))# != 0)
any(!is.na(as.matrix(s.sub)))# != 0)
length(c(2:(T-1)))
T
idx <- vector(0,length=T-2)
?vector
idx <- as.vector(0,length=T-2)
idx <- vector('logical',length=T-2)
for(i in 2:(T-1)){
idx[i-1] <- any(!is.na(as.matrix(s.sub[[i]])))# != 0)
}
i
s.sub
idx.pdt <- vector('logical', length = T - 2)
idx.locs <- vector('logical', length = T - 2)
idx.pdt <- vector('logical', length = T - 2)
idx.locs <- vector('logical', length = T - 2)
for(i in 2:(T-1)){
idx.pdt[i - 1] <- any(!is.na(as.matrix(L.pdt[[i]])))
idx.locs[i - 1] <- any(!is.na(as.matrix(L.locs[[i]])))
}
idx.pdt
idx.locs
i=2
idx.locs[i]
idx.pdt[i]
which(idx.locs | idx.pdt)
which(idx.locs[i] | idx.pdt[i])
which(idx.pdt[i] | idx.locs[i])
which(idx.pdt[i] & idx.locs[i])
c(idx.locs[i], idx.pdt[i])
idx1 <- c(idx.locs[i], idx.pdt[i])
idx1[1] & idx1[2]
which(idx1)
which(idx.pdt & idx.locs)
which(idx.pdt)
which(idx.locs)
idx <- which(c(idx.locs[i], idx.pdt[i]))
j
i
idx
i=3
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
idx == c(1,2)
sum(idx) == 3
sum(idx) == 2
for(i in 2:(T-1)){
idx <- which(c(idx.locs[i], idx.pdt[i]))
if(sum(idx) == 3){
r <- L.pdt[[i]] * L.locs[[i]]
} else if(sum(idx) == 2){
r <- L.pdt[[i]]
} else if(sum(idx) == 1){
r <- L.locs[[i]]
}
# r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
s
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
s
plot(s)
plot(s[[1]])
plot(countriesLow,add=T)
plot(s[[2]])
plot(countriesLow,add=T)
plot(s[[5]])
plot(s[[4]])
plot(countriesLow,add=T)
i=5
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
plot(L.pdt[[5]])
plot(L.locs[[5]])
L.locs[[5]]
dateVec[5]
locs[5,]
locs[4,]
locs[4,]
locs[3,]
locs[2,]
any(!is.na(as.matrix(L.locs[[5]])))
idx.locs
idx.pdt <- vector('logical', length = T)
idx.locs <- vector('logical', length = T)
for(i in 2:(T-1)){
idx.pdt[i] <- any(!is.na(as.matrix(L.pdt[[i]])))
idx.locs[i] <- any(!is.na(as.matrix(L.locs[[i]])))
}
idx.locs
i=2
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
plot(L.pdt[[2]])
plot(L.locs[[2]])
i=3
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
plot(L.pdt[[2]])
plot(L.pdt[[3]])
plot(L.locs[[3]])
for(i in 2:(T-1)){
idx <- which(c(idx.locs[i], idx.pdt[i]))
if(sum(idx) == 3){
r <- L.pdt[[i]] * L.locs[[i]]
} else if(sum(idx) == 2){
r <- L.pdt[[i]]
} else if(sum(idx) == 1){
r <- L.locs[[i]]
}
# r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
s
plot(s[[1]])
plot(s[[2]])
plot(s[[3]])
plot(s[[4]])
cbind(idx.pdt,idx.locs)
i=1
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
sum(idx)
dateIdx <- 0
for(i in 2:(T-1)){
idx <- which(c(idx.locs[i], idx.pdt[i]))
if(sum(idx) == 3){
r <- L.pdt[[i]] * L.locs[[i]]
} else if(sum(idx) == 2){
r <- L.pdt[[i]]
} else if(sum(idx) == 1){
r <- L.locs[[i]]
} else if(sum(idx) == 0){
dateIdx = c(dateIdx, i)
}
# r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
dateIdx
c(1,181) %in% seq(1:T)
which(c(1,181) %in% seq(1:T))
which(seq(1:T) %in% c(1,181))
which(seq(1:T) !%in% c(1,181))
(seq(1:T) !%in% c(1,181))
(seq(1:T) %in% c(1,181))
!(seq(1:T) %in% c(1,181))
which(!(seq(1:T) %in% c(1,181)))
!(seq(1:T) %in% dateIdx)
which(!(seq(1:T) %in% dateIdx))
s.sub <- subset(s, which(!(seq(1:T) %in% dateIdx)))
s
s.sub
plot(s.sub[[1]])
plot(s.sub[[19]])
plot(s.sub[[20]])
dateVec[19]
locs
cbind(idx.pdt,idx.locs)
dateVec[19]
pdt
pdt[1:100,]
pdt[1:150,]
dateVec[19]
plot(L.pdt[[19]])
L.pdt[[19]]
L.locs[[2]]
L.locs[[3]]
any(L.pdt[[19]] != 0)
any(as.matrix(L.pdt[[19]] != 0))
idx.pdt <- vector('logical', length = T)
idx.locs <- vector('logical', length = T)
for(i in 2:(T-1)){
idx.pdt[i] <- any(as.matrix(L.pdt[[i]]) != )
idx.locs[i] <- any(!is.na(as.matrix(L.locs[[i]])))
}
for(i in 2:(T-1)){
idx.pdt[i] <- any(as.matrix(L.pdt[[i]]) != 0)
idx.locs[i] <- any(!is.na(as.matrix(L.locs[[i]])))
}
dateIdx <- 0
for(i in 2:(T-1)){
idx <- which(c(idx.locs[i], idx.pdt[i]))
if(sum(idx) == 3){
r <- L.pdt[[i]] * L.locs[[i]]
} else if(sum(idx) == 2){
r <- L.pdt[[i]]
} else if(sum(idx) == 1){
r <- L.locs[[i]]
} else if(sum(idx) == 0){
dateIdx = c(dateIdx, i)
}
# r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
which(!(seq(1:T) %in% dateIdx))
s.sub <- subset(s, which(!(seq(1:T) %in% dateIdx)))
s.sub
plot(s.sub[[18]])
plot(s.sub[[19]])
plot(s.sub[[21]])
T <- dim(s.sub)[3]
T
L <- aperm(s.sub, c(3,2,1))
str(as.array(s.sub))
s.sub
L <- aperm(as.array(s.sub), c(3,2,1))
image.plot(lon,lat,L[3,,])
str(lon)
str(lat)
image.plot(lon,lat,t(L[3,,]))
L <- aperm(as.array(flip(s.sub, direction = 'y')), c(3,2,1))
image.plot(lon,lat,t(L[3,,]))
image.plot(lon,lat,L[3,,])
image.plot(lon, lat, L[4,,])
image.plot(lon, lat, L[3,,])
T <- dim(L)[1]
T
par0=c(8.908,10.27,1.152,0.0472,0.707,0.866)
D1 <- par0[1:2]
D2 <- par0[3:4]
p <- par0[5:6]
str(g)
G1 <- make.kern(D1,g)
dt
dt <- 1
K1 <- uniformization(G1,dt)
tr <- read.table(paste(ptt,'-SPOT.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
str(tr)
tr <- tr[,c(4, 7, 8)]
tr$b <- 1 # set an arbitrary state at this point
str(tr)
tag
pop
dts <- as.POSIXct(tr$date, format = findDateFormat(tr$date))
dts <- as.POSIXct(tr$date, format = '%m/%d/%y %H:%M')
str(tr)
colnames(tr) <- list('date','lat','lon','b')
dts <- as.POSIXct(tr$date, format = findDateFormat(tr$date))#'%m/%d/%y %H:%M')
head(dts)
didx <- dts >= tag & dts <= pop
tr <- tr[didx,]
str(tr)
plot(tr$lon,tr$lat,type='l')
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
calc.pdt
devtools::load_all(".")
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
didx <- dts >= tag & dts <= pop
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
i=1
time <- as.Date(udates[i])
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
# check woa data
graphics.off()
image.plot(lon,lat,dat[,,1,1])
# perform matching
# 'stack' makes the end of this routine much slower than 'brick' or 'array'
# but is only 10 extra seconds or so
L.pdt <- calc.pdt(pdt, dat, lat, lon, raster = 'stack', dateVec = dateVec)
data(countriesLow)
plot(L.pdt[[4]])
plot(countriesLow, add = T)
?spatial_sync_raster
devtools::load_all(".")
