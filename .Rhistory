#'  D2 <- exp(fit$estimate[3:4])
#'  p <- 1/(1+exp(-fit$estimate[5:6]))
#'
get.nll.fun <- function(parvec=c(D1, D2, p), g, L, dt){
K1 = as.cimg(gausskern(parvec[1], parvec[2], muadv = 0))
K2 = as.cimg(gausskern(parvec[3], parvec[4], muadv = 0))
P <- matrix(c(parvec[5], 1-parvec[5], 1-parvec[6], parvec[6]), 2, 2, byrow = TRUE)
# make all NA's very tiny for the convolution
# the previous steps may have taken care of this...
L[L==0] = 1e-15
L[is.na(L)] = 1e-15
# filter - moved function to sphmmfuns_hmm
f = hmm.filter2(g,L,K1,K2,P)
nllf <- -sum(log(f$psi))
##print(nllf)
cat("\r HMM -log(L):",nllf); flush.console()
nllf
}
#
# neg.log.lik.fun <- function(parvec,g,L,dt){
#   ## Calculating the likelihood of the parameters
#
#   ## Transform parameters
#   D1 <- exp(parvec[1:2])
#   D2 <- exp(parvec[3:4])
#   p1 <- exp(parvec[5])/(1+exp(parvec[5])) # inv logit
#   p2 <- exp(parvec[6])/(1+exp(parvec[6])) # inv logit
#   P <- matrix(c(p1,1-p1,1-p2,p2),2,2,byrow=TRUE)
#   ## Calculate transition matrices for the two behaviours
#   G1 <- make.kern(D1,g,dt)
#   K1 <- uniformization(G1,dt)
#   G2 <- make.kern(D2,g,dt)
#   K2 <- uniformization(G2,dt)
#   ## Evaluate filter, returns likelihood value
#   f <- hmm.filter(g,L,K1,K2,P)
#   nllf <- -sum(log(f$psi))
#   ##print(nllf)
#   cat("\r HMM -log(L):",nllf); flush.console()
#   nllf
# }
#
# guess <- c(log(10),log(10),log(0.5),log(0.5),log(0.95/0.05),log(0.95/0.05))
# fit <- nlm(neg.log.lik.fun,guess,g,L,dt)
# D1 <- exp(fit$estimate[1:2])
# D2 <- exp(fit$estimate[3:4])
# p <- 1/(1+exp(-fit$estimate[5:6]))
#
D1
D2
p
par0=c(8.908,10.27,3,1,0.707,0.866) # what units are these?
D1 <- par0[1:2] # parameters for kernel 1. this is behavior mode transit
D2 <- par0[3:4] # parameters for kernel 2. resident behavior mode
p <- par0[5:6] # logit-transformed transition probabilities for switching between the two behavioural states
class(L)
str(L)
nllf <- get.nll.hmm(parvec=c(D1, D2, p), g, L)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
get.nll.fun
nllf <- get.nll.hmm(parvec=c(D1, D2, p), g, L)
nllf <- get.nll.fun(parvec=c(D1, D2, p), g, L)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
search()
library(imager)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
nllf <- get.nll.fun(parvec=c(D1, D2, p), g, L)
nllf
?get.nll.fun
?nlm
?sphmm
library(sphmm)
fit <- nlm(get.nll.fun, par0, L, dt)
#' Negative Log likelihood of parameters
#'
#' @param parvec vector of length 6 contianing
#' * kernel 1
#' * kernel 2
#' * diagonal of 2x2 matrix
#' @param g grid from \code{\link{setup.grid}}
#' @param L final likelihood (2D)
#' @param dt time step
#'
#' @return parameter values
#' @export
#'
#' @examples
#' # NOT RUN
#'
#'  par0 <- c(log(10), log(10), log(0.5), log(0.5), log(0.95/0.05), log(0.95/0.05))
#'  fit <- nlm(neg.log.lik.fun, par0, L, dt)
#'  D1 <- exp(fit$estimate[1:2])
#'  D2 <- exp(fit$estimate[3:4])
#'  p <- 1/(1+exp(-fit$estimate[5:6]))
#'
get.nll.fun <- function(parvec=c(D1, D2, p), g, L, dt){
K1 = as.cimg(gausskern(parvec[1], parvec[2], muadv = 0))
K2 = as.cimg(gausskern(parvec[3], parvec[4], muadv = 0))
P <- matrix(c(parvec[5], 1-parvec[5], 1-parvec[6], parvec[6]), 2, 2, byrow = TRUE)
# filter - moved function to sphmmfuns_hmm
f = hmm.filter2(g,L,K1,K2,P)
nllf <- -sum(log(f$psi))
##print(nllf)
cat("\r HMM -log(L):",nllf); flush.console()
nllf
}
#
# neg.log.lik.fun <- function(parvec,g,L,dt){
#   ## Calculating the likelihood of the parameters
#
#   ## Transform parameters
#   D1 <- exp(parvec[1:2])
#   D2 <- exp(parvec[3:4])
#   p1 <- exp(parvec[5])/(1+exp(parvec[5])) # inv logit
#   p2 <- exp(parvec[6])/(1+exp(parvec[6])) # inv logit
#   P <- matrix(c(p1,1-p1,1-p2,p2),2,2,byrow=TRUE)
#   ## Calculate transition matrices for the two behaviours
#   G1 <- make.kern(D1,g,dt)
#   K1 <- uniformization(G1,dt)
#   G2 <- make.kern(D2,g,dt)
#   K2 <- uniformization(G2,dt)
#   ## Evaluate filter, returns likelihood value
#   f <- hmm.filter(g,L,K1,K2,P)
#   nllf <- -sum(log(f$psi))
#   ##print(nllf)
#   cat("\r HMM -log(L):",nllf); flush.console()
#   nllf
# }
#
# guess <- c(log(10),log(10),log(0.5),log(0.5),log(0.95/0.05),log(0.95/0.05))
# fit <- nlm(neg.log.lik.fun,guess,g,L,dt)
# D1 <- exp(fit$estimate[1:2])
# D2 <- exp(fit$estimate[3:4])
# p <- 1/(1+exp(-fit$estimate[5:6]))
#
L[L==0] = 1e-15
L[is.na(L)] = 1e-15
fit <- nlm(get.nll.fun, par0, L, dt)
str(g)
str(g$lon)
?nlm
par0
fit <- nlm(get.nll.fun, par0, L)
get.nll.fun
par0 <- c(log(10), log(10), log(0.5), log(0.5), log(0.95/0.05), log(0.95/0.05))
fit <- nlm(get.nll.fun, par0, g, L, dt)
str(fit)
fit
par0
par0=c(8.908,10.27,3,1,0.707,0.866) # what units are these?
fit <- nlm(get.nll.fun, par0, g, L, dt)
Sys.time()
#started at 13:51
str(fit)
fit$estimate
par0
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
str(pdt)
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
str(pdt)
pdt <- extract.pdt(pdt)
names(data) == 'Depth1'
names(data)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
?raster
?extent
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
calc.loc
calc.locs
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
L.locs
plot(L[[1]])
plot(L[1])
plot(L.locs[[1]])
plot(L.locs[1])
plot(L.locs[[1]])
str(L.locs[[1]])
print(class(L.locs))
L.locs[[1]]
i=10
plot(L.locs[[i]], main=paste(dateVec[i]))
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L.locs <- array(0, dim = c(col, row, length(dateVec)))
# Initial location is known
ilo <- which.min(abs(g$lon[1,] - iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1] - iniloc$lat[1]))
L.locs[ilo, ila, 1] <- 1
locDates <- as.Date(locs$Date, format = findDateFormat(locs$Date))
# set up a larger grid to base ellipse on and to shift that error, if necessary (GPE only)
ngrid <- rev(dim(g$lon))
lon1 <- seq(min(g$lon[1,]) - 10, max(g$lon[1,]) + 10, by = g$dlo)
lat1 <- seq(min(g$lat[,1]) - 10, max(g$lat[,1]) + 10, by = g$dla)
g1 <- meshgrid(lon1, lat1)
locs$Offset[which(is.na(locs$Offset))] <- 0
t=1
locs[t,]
locs$Type[t] == 'GPE'
slon.sd <- locs$Error.Semi.minor.axis[t] / 1000 / 111 #semi minor axis
L.light.lon <- dnorm(t(g1$X), locs$Longitude[t], slon.sd) # Longitude data
slat.sd <- locs$Error.Semi.major.axis[t] / 1000 / 111 #semi major axis
L.light.lat <- dnorm(t(g1$Y), locs$Latitude[t], slat.sd)
#image.plot(g$lon[1,],g$lat[,1],L.light.lat*L.light.lon)
L <- raster::flip(raster(t(L.light.lat * L.light.lon), xmn = min(lon1),
xmx = max(lon1), ymn = min(lat1), ymx = max(lat1)), direction = 'y')
L <- raster::flip(raster::raster(t(L.light.lat * L.light.lon), xmn = min(lon1),
xmx = max(lon1), ymn = min(lat1), ymx = max(lat1)), direction = 'y')
# offset, assuming shift should be to the south
shiftDist <- (-1 * (locs$Offset[t] / 1000 / 111))
shiftDist
Ls <- raster::shift(L, y = shiftDist)
L.ext <- raster::flip(raster(g$lon, xmn = min(lon),
xmx = max(lon), ymn = min(lat), ymx = max(lat)), direction = 'y')
L.ext <- raster::flip(raster::raster(g$lon, xmn = min(lon),
xmx = max(lon), ymn = min(lat), ymx = max(lat)), direction = 'y')
L.ext[L.ext <= 0] = 1
# then crop our shifted raster
Lsx <- raster::crop(Ls, L.ext)
rr <- raster::resample(Lsx, L.ext)
#image.plot(lon,lat,t(as.matrix(flip(rr,direction='y'))))
L.locs[,,which(dateVec == locDates[t])] <- t(as.matrix(flip(rr, direction = 'y')))
L.locs[,,which(dateVec == locDates[t])] <- t(as.matrix(raster::flip(rr, direction = 'y')))
which(dateVec==locDates[t])
rr
plot(rr)
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
#---------------------------------------------------------------#
# LIGHT
#---------------------------------------------------------------#
# Light-based Longitude Likelihood (ellipse error is a work in progress)
# do light first so that g is setup for both
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L.locs <- array(0, dim = c(col, row, length(dateVec)))
# Initial location is known
ilo <- which.min(abs(g$lon[1,] - iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1] - iniloc$lat[1]))
L.locs[ilo, ila, 1] <- 1
locDates <- as.Date(locs$Date, format = findDateFormat(locs$Date))
# set up a larger grid to base ellipse on and to shift that error, if necessary (GPE only)
ngrid <- rev(dim(g$lon))
lon1 <- seq(min(g$lon[1,]) - 10, max(g$lon[1,]) + 10, by = g$dlo)
lat1 <- seq(min(g$lat[,1]) - 10, max(g$lat[,1]) + 10, by = g$dla)
g1 <- meshgrid(lon1, lat1)
locs$Offset[which(is.na(locs$Offset))] <- 0
t=1
slon.sd <- locs$Error.Semi.minor.axis[t] / 1000 / 111 #semi minor axis
L.light.lon <- dnorm(t(g1$X), locs$Longitude[t], slon.sd) # Longitude data
slat.sd <- locs$Error.Semi.major.axis[t] / 1000 / 111 #semi major axis
L.light.lat <- dnorm(t(g1$Y), locs$Latitude[t], slat.sd)
locs[t]
locs[t,]
L <- raster::flip(raster::raster(t(L.light.lat * L.light.lon), xmn = min(lon1),
xmx = max(lon1), ymn = min(lat1), ymx = max(lat1)), direction = 'y')
plot(L)
library(fields)
image.plot(L.light.lat)
image.plot(L.light.lon)
image.plot(t(L.light.lat * L.light.lon))
min(lon1)
max(lon1)
min(lat1)
max(lat1)
plot(raster::raster(t(L.light.lat * L.light.lon), xmn = min(lon1),
xmx = max(lon1), ymn = min(lat1), ymx = max(lat1)))
raster::raster(t(L.light.lat * L.light.lon), xmn = min(lon1),
xmx = max(lon1), ymn = min(lat1), ymx = max(lat1))
?raster::raster
library(raster)
L <- raster::flip(raster::raster(t(L.light.lat * L.light.lon), xmn = min(lon1),
xmx = max(lon1), ymn = min(lat1), ymx = max(lat1)), direction = 'y')
plot(L)
detach('package:raster',unload=T)
detach('package:spatial.tools',unload=T)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
plot(L.locs[[1]])
plot(L.locs[[4]])
plot(L.locs[[3]])
plot(L.locs[[10]])
t
locs[t,]
which(dateVec == locDates[t])
plot(L)
shiftDist <- (-1 * (locs$Offset[t] / 1000 / 111))
shiftDist
shiftDist >= -10
Ls <- raster::shift(L, y = shiftDist)
L.ext <- raster::flip(raster::raster(g$lon, xmn = min(lon),
xmx = max(lon), ymn = min(lat), ymx = max(lat)), direction = 'y')
# create blank raster
L.ext[L.ext <= 0] = 1
# then crop our shifted raster
Lsx <- raster::crop(Ls, L.ext)
rr <- raster::resample(Lsx, L.ext)
#image.plot(lon,lat,t(as.matrix(flip(rr,direction='y'))))
L.locs[,,which(dateVec == locDates[t])] <- t(as.matrix(raster::flip(rr, direction = 'y')))
plot(rr)
str(t(as.matrix(raster::flip(rr, direction = 'y'))))
L.locs <- array(0, dim = c(col, row, length(dateVec)))
# Initial location is known
ilo <- which.min(abs(g$lon[1,] - iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1] - iniloc$lat[1]))
L.locs[ilo, ila, 1] <- 1
locDates <- as.Date(locs$Date, format = findDateFormat(locs$Date))
L.locs[,,which(dateVec == locDates[t])] <- t(as.matrix(raster::flip(rr, direction = 'y')))
image.plot(L.locs[,,4])
data("countriesLow")
#---------------------------------------------------------------#
# read in tag data
#---------------------------------------------------------------#
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
d1 <- as.POSIXct('1900-01-02') - as.POSIXct('1900-01-01')
didx <- dts >= (tag + d1) & dts <= (pop - d1)
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
#---------------------------------------------------------------#
# LIGHT
#---------------------------------------------------------------#
# Light-based Longitude Likelihood (ellipse error is a work in progress)
# do light first so that g is setup for both
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > (tag + d1) & dts < (pop - d1)
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
#' Calculate Position-based Likelihood
#'
#' \code{calc.locs} calculates likelihood estimates for each day of animal tag
#' data.
#'
#' Light errors are parameterized using elliptical error values output in
#' '-Locations.csv' (WC tags). GPS and Argos positions are also given a
#' "likelihood" using this function but are currently both considered to be
#' "known" positions without error.
#'
#' @param locs is -Locations file output from DAP/Tag Portal for WC tags and
#'   contains GPS, Argos, and GPE locations as applicable
#' @param iniloc is 2 x 5 dataframe containing day, month, year, lat, lon for
#'   both tag and pop locations
#' @param g is output from setup.grid and indicates extent and resolution of
#'   grid used to calculate likelihoods
#' @param raster is logical indicating whether to return likelihood as a raster
#'   or an array. Default is TRUE and will return a raster.
#' @param dateVec is vector of dates from tag to pop-up in 1 day increments.
#' @param errEll is logical indicating whether error ellipses should be
#'   generated for light-based likelihoods as given from output of WC-GPE. False
#'   if only longitude should be used. If False, standard deviation on light
#'   measurements is currently fixed at 0.7 deg longitude following Musyl et al
#'   2001. Default is FALSE and will use longitude only.
#' @return L is an array of lon x lat likelihood surfaces (matrices) for each
#'   time point (3rd dimension)
calc.locs <- function(locs, iniloc, g, raster = TRUE, dateVec, errEll = F){
T <- length(locs$Longitude)
row <- dim(g$lon)[1]
col <- dim(g$lon)[2]
L.locs <- array(0, dim = c(col, row, length(dateVec)))
# Initial location is known
ilo <- which.min(abs(g$lon[1,] - iniloc$lon[1]))
ila <- which.min(abs(g$lat[,1] - iniloc$lat[1]))
L.locs[ilo, ila, 1] <- 1
locDates <- as.Date(locs$Date, format = findDateFormat(locs$Date))
# set up a larger grid to base ellipse on and to shift that error, if necessary (GPE only)
ngrid <- rev(dim(g$lon))
lon1 <- seq(min(g$lon[1,]) - 10, max(g$lon[1,]) + 10, by = g$dlo)
lat1 <- seq(min(g$lat[,1]) - 10, max(g$lat[,1]) + 10, by = g$dla)
g1 <- meshgrid(lon1, lat1)
locs$Offset[which(is.na(locs$Offset))] <- 0
for(t in 1:T){
if(locs$Type[t] == 'GPS'){
# if GPS exists then other forms of data for that time point are obsolete
glo <- which.min(abs(g$lon[1,] - locs$Longitude[t]))
gla <- which.min(abs(g$lat[,1] - locs$Latitude[t]))
L.locs[glo, gla, which(dateVec == locDates[t])] <- 1
} else if(locs$Type[t] == 'Argos'){
# if Argos exists, GPE positions are obsolete
alo <- which.min(abs(g$lon[1,] - locs$Longitude[t]))
ala <- which.min(abs(g$lat[,1] - locs$Latitude[t]))
L.locs[alo, ala, which(dateVec == locDates[t])] <- 1
} else if(locs$Type[t] == 'GPE'){
if(errEll == FALSE){
# create longitude likelihood based on GPE data
# SD for light-based longitude from Musyl et al. (2001)
slon.sd <- 35 / 111 # Converting from kms to degrees
# use normally distributed error from position using fixed std dev
L.light <- dnorm(t(g$lon), locs$Longitude[t], slon.sd)
L.locs[,,which(dateVec == locDates[t])] <- L.light
} else if(errEll == TRUE){
# arithmetic converts from meters to degrees
# add transformation due to projection?
slon.sd <- locs$Error.Semi.minor.axis[t] / 1000 / 111 #semi minor axis
L.light.lon <- dnorm(t(g1$X), locs$Longitude[t], slon.sd) # Longitude data
slat.sd <- locs$Error.Semi.major.axis[t] / 1000 / 111 #semi major axis
L.light.lat <- dnorm(t(g1$Y), locs$Latitude[t], slat.sd)
#image.plot(g$lon[1,],g$lat[,1],L.light.lat*L.light.lon)
L <- raster::flip(raster::raster(t(L.light.lat * L.light.lon), xmn = min(lon1),
xmx = max(lon1), ymn = min(lat1), ymx = max(lat1)), direction = 'y')
# offset, assuming shift should be to the south
shiftDist <- (-1 * (locs$Offset[t] / 1000 / 111))
if(shiftDist >= -10){
Ls <- raster::shift(L, y = shiftDist)
L.ext <- raster::flip(raster::raster(g$lon, xmn = min(lon),
xmx = max(lon), ymn = min(lat), ymx = max(lat)), direction = 'y')
# create blank raster
L.ext[L.ext <= 0] = 1
# then crop our shifted raster
Lsx <- raster::crop(Ls, L.ext)
rr <- raster::resample(Lsx, L.ext)
#image.plot(lon,lat,t(as.matrix(flip(rr,direction='y'))))
L.locs[,,which(dateVec == locDates[t])] <- t(as.matrix(raster::flip(rr, direction = 'y')))
} else{
# if supposed shift in error ellipse is >10 degrees, we revert to longitude only
slon.sd <- 35/111 # Converting from kms to degrees
L.light <- dnorm(t(g$lon), locs$Longitude[t], slon.sd)
L.locs[,,which(dateVec == locDates[t])] <- L.light
}
}
} else{
stop('No data type for this days location.')
}
#image.plot(lon,lat,L.locs[,,which(dateVec == locDates[t])], main=paste(dateVec[which(dateVec==locDates[t])]))
}
# End location is known
elo <- which.min(abs(g$lon[1,] - iniloc$lon[2]))
ela <- which.min(abs(g$lat[,1] - iniloc$lat[2]))
L.locs[elo, ela, length(dateVec)] <- 1
if(raster){
# this performs some transformations to the likelihood array to convert to useable raster
crs <- "+proj=longlat +datum=WGS84 +ellps=WGS84"
list.locs <- list(x = g$lon[1,], y = g$lat[,1], z = L.locs)
ex <- raster::extent(list.locs)
L.locs <- raster::brick(list.locs$z, xmn = ex[1], xmx = ex[2], ymn = ex[3], ymx = ex[4], transpose = T, crs)
L.locs <- raster::flip(L.locs, direction = 'y')
L.locs <- raster::stack(L.locs)
}
print(class(L.locs))
return(L.locs)
}
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec, errEll=T)
plot(L.locs[[1]])
plot(L.locs[[4]])
