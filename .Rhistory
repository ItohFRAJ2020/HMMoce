image.plot(lon,lat,s[2,i,,])
par(mfrow=c(2,1))
image.plot(lon,lat,f$phi[1,i,,])
image.plot(lon,lat,f$phi[2,i,,])
image.plot(lon,lat,f$pred[1,i,,])
image.plot(lon,lat,f$pred[2,i,,])
T <- dim(f$phi)[2]
row <- dim(f$phi)[3]
col <- dim(f$phi)[4]
K1 <- imager::as.cimg(K1)
K2 <- imager::as.cimg(K2)
K1
smooth <- f$phi  #default; fill in as the prediction step.
i
for(t in T:162){
RAT <- smooth[,t,,] / (f$pred[,t,,] + 1e-15)
#     Rp1 <- as.vector(K1 %*% as.vector(RAT[1,,]))
#     Rp2 <- as.vector(K2 %*% as.vector(RAT[2,,]))
p1 = imager::as.cimg(t(RAT[1,,]))
Rp1 <- imager::convolve(p1, K1)
p2 = imager::as.cimg(t(RAT[2,,]))
Rp2 <- imager::convolve(p2, K2)
Rp1 = t(as.matrix(Rp1))
Rp2 = t(as.matrix(Rp2))
if(plot){
par(mfrow = c(1,2))
image.plot(Rp1)
#plot(countriesLow,add=T)
image.plot(Rp2)
#plot(countriesLow,add=T)
}
post1 <- matrix(P[1,1] * Rp1 + P[1,2] * Rp2, row, col)
post2 <- matrix(P[2,1] * Rp1 + P[2,2] * Rp2, row, col)
if(T == t){
post1 <- f$phi[1,t,,]
post2 <- f$phi[2,t,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
smooth[1,t,,] <- post1 / fac
smooth[2,t,,] <- post2 / fac
post1 <- post1 * f$phi[1,t-1,,]
post2 <- post2 * f$phi[2,t-1,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
smooth[1,t-1,,] <- post1 / fac
smooth[2,t-1,,] <- post2 / fac
}else{
post1 <- post1 * f$phi[1,t-1,,]
post2 <- post2 * f$phi[2,t-1,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
smooth[1,t-1,,] <- post1 / fac
smooth[2,t-1,,] <- post2 / fac
}
}
t
t=161
RAT <- smooth[,t,,] / (f$pred[,t,,] + 1e-15)
str(RAT)
image.plot(lon,lat,RAT[1,,]])
image.plot(lon,lat,RAT[1,,])
image.plot(lon,lat,RAT[2,,])
t
image.plot(lon,lat,f$phi[1,t,,])
image.plot(lon,lat,RAT[1,,])
image.plot(lon,lat,f$phi[1,t,,])
image.plot(lon,lat,f$phi[2,t,,])
smooth <- f$phi  #default; fill in as the prediction step.
t=T
RAT <- smooth[,t,,] / (f$pred[,t,,] + 1e-15)
image.plot(lon,lat,RAT[1,,])
points(iniloc[2,c(5,4)])
p1 = imager::as.cimg(t(RAT[1,,]))
Rp1 <- imager::convolve(p1, K1)
p2 = imager::as.cimg(t(RAT[2,,]))
Rp2 <- imager::convolve(p2, K2)
Rp1 = t(as.matrix(Rp1))
Rp2 = t(as.matrix(Rp2))
str(Rp1)
image.plot(lon,lat,Rp1)
post1 <- f$phi[1,t,,]
post2 <- f$phi[2,t,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
t
smooth[1,t,,] <- post1 / fac
smooth[2,t,,] <- post2 / fac
image.plot(lon,lat,smooth[1,t,,])
image.plot(lon,lat,smooth[2,t,,])
points(iniloc[2,c(5,4)])
post1 <- post1 * f$phi[1,t-1,,]
post2 <- post2 * f$phi[2,t-1,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
smooth[1,t-1,,] <- post1 / fac
smooth[2,t-1,,] <- post2 / fac
image.plot(lon,lat,smooth[1,t-1,,])
image.plot(lon,lat,smooth[1,t,,])
post1 <- f$phi[1,t,,]
post2 <- f$phi[2,t,,]
post1 <- post1 * f$phi[1,t-1,,]
post2 <- post2 * f$phi[2,t-1,,]
str(post1)
image.plot(lon,lat,post1)
image.plot(lon,lat,post2)
image.plot(lon,lat,f$phi[1,t,,])
image.plot(lon,lat,f$phi[1,t-1,,])
image.plot(lon,lat,f$phi[1,t,,])
world(add=T,fill=T)
title('f$phi[1,181,,] - popup')
points(iniloc[2,c(5,4)])
image.plot(lon,lat,f$phi[1,t-1,,])
world(add=T,fill=T)
title('f$phi[1,180,,] - before pop')
image.plot(lon,lat,f$pred[1,t,,])
world(add=T,fill=T)
title('f$pred[1,181,,] - popup')
points(iniloc[2,c(5,4)])
image.plot(lon,lat,f$pred[1,t-1,,])
world(add=T,fill=T)
title('f$pred[1,180,,] - before pop')
image.plot(lon,lat,L[t-1,,])
world(add=T,fill=T)
title('L[180,,] - before pop')
points(iniloc[2,c(5,4)])
image.plot(lon,lat,f$phi[1,t-1,,])
world(add=T,fill=T)
title('f$phi[1,180,,] - before pop')
image.plot(lon,lat,L[177,,])
world(add=T,fill=T)
image.plot(lon,lat,L[178,,])
world(add=T,fill=T)
image.plot(lon,lat,L[179,,])
world(add=T,fill=T)
image.plot(lon,lat,L[180,,])
world(add=T,fill=T)
T <- dim(L)[1] # dimension of time
row <- dim(g$lon)[1] # nrows
col <- dim(g$lon)[2] # ncols
m <- 2 # Number of behavioural states
pred <- array(0, dim = c(m, T, col, row)) # empty array for prediction step. ordering in col before row emulates lon before lat
phi  <- array(0, dim = c(m, T, col, row)) # posterior (final) step array
# Start in resident state at the known initial location
phi[1,1,,]  <- L[1,,] # first position is known
phi[2,1,,]  <- L[1,,] # first position is known
pred[1,1,,] <- L[1,,] # first position is known
pred[2,1,,] <- L[1,,] # first position is known
psi <- rep(0, T - 1) # sum of the probability of both states at each step
K1 <- imager::as.cimg(K1)
K2 <- imager::as.cimg(K2)
for(t in 2:(T-5)){
# replace this part with older workflow using a gaussian kernel..
# p1 <- as.vector(phi[1,t-1,,])
# p2 <- as.vector(phi[2,t-1,,])
# q1 <- as.vector(p1%*%K1)
# q2 <- as.vector(p2%*%K2)
p1 = imager::as.cimg(t(phi[1, t-1,,]))
p2 = imager::as.cimg(t(phi[2, t-1,,]))
q1 = imager::convolve(p1, K1)
q2 = imager::convolve(p2, K2)
# q1 = arot(t(as.matrix(q1)),3)
# q2 = arot(t(as.matrix(q2)),3)
q1 = t(as.matrix(q1))
q2 = t(as.matrix(q2))
# 	par(mfrow=c(1,2))
# 	image(q1)
# 	image(q2)
# pred[1,t,,] <- matrix(P[1,1]*q1+P[2,1]*q2,row,col)
# pred[2,t,,] <- matrix(P[1,2]*q1+P[2,2]*q2,row,col)
# multiply by transition probability
pred[1,t,,] <- P[1,1] * q1 + P[2,1] * q2
pred[2,t,,] <- P[1,2] * q1 + P[2,2] * q2
sumL = sum(L[t,,])
if(sumL > 0){
post1 <- pred[1,t,,] * L[t,,]
post2 <- pred[2,t,,] * L[t,,]
}else{
post1 <- pred[1,t,,]
post2 <- pred[2,t,,]
}
psi[t-1] <- sum(as.vector(post1), na.rm=T) + sum(as.vector(post2), na.rm=T)
# remove NaNs...
# normalise (divide here by sum, not max)
# 	post1 <- normalise(post1)
# 	post2 <- normalise(post2)
# 	post1[is.nan(post1)] = 0
# 	post2[is.nan(post2)] = 0
phi[1,t,,] <- post1 / (psi[t-1] + 1e-15)
phi[2,t,,] <- post2 / (psi[t-1] + 1e-15)
}
t
image.plot(lon,lat,phi[1,t,,]); world(add=T,fill=T); image.plot(lon,lat,phi[2,t,,]); world(add=T,fill=T)
t=177
p1 = imager::as.cimg(t(phi[1, t-1,,]))
p2 = imager::as.cimg(t(phi[2, t-1,,]))
q1 = imager::convolve(p1, K1)
q2 = imager::convolve(p2, K2)
# q1 = arot(t(as.matrix(q1)),3)
# q2 = arot(t(as.matrix(q2)),3)
q1 = t(as.matrix(q1))
q2 = t(as.matrix(q2))
# 	par(mfrow=c(1,2))
# 	image(q1)
# 	image(q2)
# pred[1,t,,] <- matrix(P[1,1]*q1+P[2,1]*q2,row,col)
# pred[2,t,,] <- matrix(P[1,2]*q1+P[2,2]*q2,row,col)
# multiply by transition probability
pred[1,t,,] <- P[1,1] * q1 + P[2,1] * q2
pred[2,t,,] <- P[1,2] * q1 + P[2,2] * q2
sumL = sum(L[t,,])
if(sumL > 0){
post1 <- pred[1,t,,] * L[t,,]
post2 <- pred[2,t,,] * L[t,,]
}else{
post1 <- pred[1,t,,]
post2 <- pred[2,t,,]
}
psi[t-1] <- sum(as.vector(post1), na.rm=T) + sum(as.vector(post2), na.rm=T)
# remove NaNs...
# normalise (divide here by sum, not max)
# 	post1 <- normalise(post1)
# 	post2 <- normalise(post2)
# 	post1[is.nan(post1)] = 0
# 	post2[is.nan(post2)] = 0
phi[1,t,,] <- post1 / (psi[t-1] + 1e-15)
phi[2,t,,] <- post2 / (psi[t-1] + 1e-15)
image.plot(lon,lat,phi[1,t,,]); world(add=T,fill=T); image.plot(lon,lat,phi[2,t,,]); world(add=T,fill=T)
t=178
p1 = imager::as.cimg(t(phi[1, t-1,,]))
p2 = imager::as.cimg(t(phi[2, t-1,,]))
q1 = imager::convolve(p1, K1)
q2 = imager::convolve(p2, K2)
# q1 = arot(t(as.matrix(q1)),3)
# q2 = arot(t(as.matrix(q2)),3)
q1 = t(as.matrix(q1))
q2 = t(as.matrix(q2))
# 	par(mfrow=c(1,2))
# 	image(q1)
# 	image(q2)
# pred[1,t,,] <- matrix(P[1,1]*q1+P[2,1]*q2,row,col)
# pred[2,t,,] <- matrix(P[1,2]*q1+P[2,2]*q2,row,col)
# multiply by transition probability
pred[1,t,,] <- P[1,1] * q1 + P[2,1] * q2
pred[2,t,,] <- P[1,2] * q1 + P[2,2] * q2
sumL = sum(L[t,,])
if(sumL > 0){
post1 <- pred[1,t,,] * L[t,,]
post2 <- pred[2,t,,] * L[t,,]
}else{
post1 <- pred[1,t,,]
post2 <- pred[2,t,,]
}
psi[t-1] <- sum(as.vector(post1), na.rm=T) + sum(as.vector(post2), na.rm=T)
# remove NaNs...
# normalise (divide here by sum, not max)
# 	post1 <- normalise(post1)
# 	post2 <- normalise(post2)
# 	post1[is.nan(post1)] = 0
# 	post2[is.nan(post2)] = 0
phi[1,t,,] <- post1 / (psi[t-1] + 1e-15)
phi[2,t,,] <- post2 / (psi[t-1] + 1e-15)
image.plot(lon,lat,phi[1,t,,]); world(add=T,fill=T); image.plot(lon,lat,phi[2,t,,]); world(add=T,fill=T)
points(iniloc[2,c(5,4)])
t
t=179
p1 = imager::as.cimg(t(phi[1, t-1,,]))
p2 = imager::as.cimg(t(phi[2, t-1,,]))
q1 = imager::convolve(p1, K1)
q2 = imager::convolve(p2, K2)
# q1 = arot(t(as.matrix(q1)),3)
# q2 = arot(t(as.matrix(q2)),3)
q1 = t(as.matrix(q1))
q2 = t(as.matrix(q2))
# 	par(mfrow=c(1,2))
# 	image(q1)
# 	image(q2)
# pred[1,t,,] <- matrix(P[1,1]*q1+P[2,1]*q2,row,col)
# pred[2,t,,] <- matrix(P[1,2]*q1+P[2,2]*q2,row,col)
# multiply by transition probability
pred[1,t,,] <- P[1,1] * q1 + P[2,1] * q2
pred[2,t,,] <- P[1,2] * q1 + P[2,2] * q2
sumL = sum(L[t,,])
if(sumL > 0){
post1 <- pred[1,t,,] * L[t,,]
post2 <- pred[2,t,,] * L[t,,]
}else{
post1 <- pred[1,t,,]
post2 <- pred[2,t,,]
}
psi[t-1] <- sum(as.vector(post1), na.rm=T) + sum(as.vector(post2), na.rm=T)
# remove NaNs...
# normalise (divide here by sum, not max)
# 	post1 <- normalise(post1)
# 	post2 <- normalise(post2)
# 	post1[is.nan(post1)] = 0
# 	post2[is.nan(post2)] = 0
phi[1,t,,] <- post1 / (psi[t-1] + 1e-15)
phi[2,t,,] <- post2 / (psi[t-1] + 1e-15)
image.plot(lon,lat,phi[1,t,,]); world(add=T,fill=T); image.plot(lon,lat,phi[2,t,,]); world(add=T,fill=T)
?repmat
repmat <- function(X,m,n){
mx = dim(X)[1]
nx = dim(X)[2]
matrix(t(matrix(X,mx,nx*n)),mx*m,nx*n,byrow=T)
}
par0=c(8.908,10.27,1.152,0.0472,0.707,0.866)
D1 <- par0[1:2] # parameters for kernel 1. this is behavior mode transit
D2 <- par0[3:4] # parameters for kernel 2. resident behavior mode
p <- par0[5:6]
K1 = gausskern(D1[1], D1[2], muadv = 0)
K2 = gausskern(D2[1], D2[2], muadv = 0)
P <- matrix(c(p[1],1-p[1],1-p[2],p[2]),2,2,byrow=TRUE)
f = hmm.filter(g.mle, L.mle, K1, K2, P)
s = hmm.smoother_test(f, K1, K2, P, plot = F)
distr = s
meanlat <- apply(apply(distr, c(2, 4), sum) * repmat(t(as.matrix(g$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(distr, c(2, 3), sum) * repmat(t(as.matrix(g$lon[1,])), T, 1), 1, sum)
meanlat <- apply(apply(distr, c(2, 4), sum) * repmat(t(as.matrix(g.mle$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(distr, c(2, 3), sum) * repmat(t(as.matrix(g.mle$lon[1,])), T, 1), 1, sum)
plot(meanlon,meanlat,type='l')
graphics.off()
plot(meanlon,meanlat,type='l')
world(add=T)
lines(spot$lon,spot$lat,col='blue')
str(s)
D1 <- par0[1:2]/4 # parameters for kernel 1. this is behavior mode transit
D2 <- par0[3:4]/4 # parameters for kernel 2. resident behavior mode
K1 = gausskern(D1[1], D1[2], muadv = 0)
K2 = gausskern(D2[1], D2[2], muadv = 0)
P <- matrix(c(p[1],1-p[1],1-p[2],p[2]),2,2,byrow=TRUE)
f = hmm.filter(g.mle, L.mle, K1, K2, P)
s = hmm.smoother_test(f, K1, K2, P, plot = F)
distr = s
meanlat <- apply(apply(distr, c(2, 4), sum) * repmat(t(as.matrix(g$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(distr, c(2, 3), sum) * repmat(t(as.matrix(g$lon[1,])), T, 1), 1, sum)
meanlat <- apply(apply(distr, c(2, 4), sum) * repmat(t(as.matrix(g.mle$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(distr, c(2, 3), sum) * repmat(t(as.matrix(g.mle$lon[1,])), T, 1), 1, sum)
plot(meanlon,meanlat,type='l')
world(add=T, fill=T, col='grey')
D1
D2
devtools::load_all(".")
devtools::build(binary=T)
?use_travis
devtools::use_travis()
?check
devtools::check(document=TRUE, manual=TRUE)
library(tools)
tools::showNonASCIIfile('../HMMoce/R/gausskern.r')
tools::showNonASCIIfile('../HMMoce/R/gausskern.r')
devtools::check(document=TRUE, manual=TRUE)
devtools::check(document=TRUE, manual=TRUE)
sprintf
?sprintf
?strftime
devtools::load_all(".")
lon <- c(-90, -60)
lat <- c(0, 30)
time <- as.Date('2013-03-01')
get.hycom(lon, lat, time, type='a', filename = '', vars = 'water_temp')
setwd(dir)
setwd(getwd())
type='a'
expts = data.frame(
start=c(as.Date('1992-10-02'), as.Date('1995-08-01'),
as.Date('2012-01-01'), as.Date('2013-08-21'),
as.Date('2014-04-05'), as.Date('2016-04-18')),
end=c(as.Date('1995-07-31'), as.Date('2011-12-31'),
as.Date('2013-08-20'), as.Date('2014-04-04'),
as.Date('2016-04-17'), Sys.Date() + 1),
url=c('http://ncss.hycom.org/thredds/ncss/GLBu0.08/expt_19.0?',
'http://ncss.hycom.org/thredds/ncss/GLBu0.08/expt_19.1?',
'http://ncss.hycom.org/thredds/ncss/GLBu0.08/expt_90.9?',
'http://ncss.hycom.org/thredds/ncss/GLBu0.08/expt_91.0?',
'http://ncss.hycom.org/thredds/ncss/GLBu0.08/expt_91.1?',
'http://ncss.hycom.org/thredds/ncss/GLBu0.08/expt_91.2?'))
time()
time
url = sprintf('%stime_start=%s%%3A00%%3A00Z&time_end=%s%%3A00%%3A00Z&timeStride=1&',
url, strftime(time[1], '%Y-%m-%dT00', start_time),
strftime(time[2], '%Y-%m-%dT00', end_time))
url
for(i in seq(nrow(expts))) {
if((time[1] >= expts$start[i]) & (time[1] <= expts$end[i]))
url = expts$url[i]
}
url
vars=c('water_temp')
## Add the variables.
for(var in vars)
url = sprintf('%svar=%s&', url, var)
## Add the spatial domain.
url = sprintf('%snorth=%f&west=%f&east=%f&south=%f&horizStride=1&',
url, limits[[4]], limits[[1]], limits[[2]], limits[[3]])
# north, west, east, south
spatLim = c(lon,lat)
spatLim
limits<-spatLim
## Add the variables.
for(var in vars)
url = sprintf('%svar=%s&', url, var)
## Add the spatial domain.
url = sprintf('%snorth=%f&west=%f&east=%f&south=%f&horizStride=1&',
url, limits[[4]], limits[[1]], limits[[2]], limits[[3]])
# north, west, east, south
url
url = sprintf('%stime_start=%s%%3A00%%3A00Z&time_end=%s%%3A00%%3A00Z&timeStride=1&',
url, strftime(time[1], '%Y-%m-%dT00', start_time),
strftime(time[2], '%Y-%m-%dT00', end_time))
url
for(i in seq(nrow(expts))) {
if((time[1] >= expts$start[i]) & (time[1] <= expts$end[i]))
url = expts$url[i]
}
## Add the variables.
for(var in vars)
url = sprintf('%svar=%s&', url, var)
## Add the spatial domain.
url = sprintf('%snorth=%f&west=%f&east=%f&south=%f&horizStride=1&',
url, limits[[4]], limits[[1]], limits[[2]], limits[[3]])
url1 = sprintf('%stime_start=%s%%3A00%%3A00Z&time_end=%s%%3A00%%3A00Z&timeStride=1&',
url, strftime(time[1], '%Y-%m-%dT00', start_time),
strftime(time[2], '%Y-%m-%dT00', end_time))
url2 = sprintf('%stime_start=%s%%3A00%%3A00Z&time_end=%s%%3A00%%3A00Z&timeStride=1&',
url, strftime(time[1], '%Y-%m-%dT00'),
strftime(time[1], '%Y-%m-%dT00'))
url2
url1
time
time[2] <=
time[2] <- '2013-03-02'
str(time)
url1 = sprintf('%stime_start=%s%%3A00%%3A00Z&time_end=%s%%3A00%%3A00Z&timeStride=1&',
url, strftime(time[1], '%Y-%m-%dT00'),
strftime(time[2], '%Y-%m-%dT00'))
url1
url = sprintf('%saddLatLon=true&', url)
url = sprintf('%sdisableProjSubset=on&vertCoord=&accept=netcdf', url)
for(i in seq(nrow(expts))) {
if((time[1] >= expts$start[i]) & (time[1] <= expts$end[i]))
url = expts$url[i]
}
for(var in vars)
url = sprintf('%svar=%s&', url, var)
## Add the spatial domain.
url = sprintf('%snorth=%f&west=%f&east=%f&south=%f&horizStride=1&',
url, limits[[4]], limits[[1]], limits[[2]], limits[[3]])
# north, west, east, south
to,e
time
length(time) == 2
url = sprintf('%stime_start=%s%%3A00%%3A00Z&time_end=%s%%3A00%%3A00Z&timeStride=1&',
url, strftime(time[1], '%Y-%m-%dT00'),
strftime(time[2], '%Y-%m-%dT00'))
url = sprintf('%saddLatLon=true&', url)
url = sprintf('%sdisableProjSubset=on&vertCoord=&accept=netcdf', url)
url
?check
devtools::check(manual=TRUE)
devtools::check(manual=TRUE)
?build_win
devtools::build_win()
?build_win
devtools::build_win()
devtools::load_all(".")
setwd('~/Documents/WHOI/Data/Blues/2015/141256/')
load('blue256_runL.RData')
setwd('~/Documents/WHOI/Data/Blues/2015/141259/')
load('blue259_runL.RData')
str(L)
locs <- read.table('141259-Locations-GPE2.csv', sep = ',', header = T, blank.lines.skip = F)
locs.grid <- setup.locs.grid(locs)
L.rasters <- list(L.sst = L.sst, L.light = L.light)
L.res <- resample.grid(L.rasters, L.rasters$L.sst)
L.mle.res <- L.res$L.mle.res
g <- L.res$g; lon <- g$lon[1,]; lat <- g$lat[,1]
g.mle <- L.res$g.mle
sp.lim <- list(lonmin = -82, lonmax = -25, latmin = 15, latmax = 50)
locs.grid <- setup.locs.grid(sp.lim)
L <- make.L(L1 = L.res[[1]]$L.sst,
L2 = L.res[[1]]$L.light,
L.mle.res = L.mle.res, dateVec = dateVec,
locs.grid = locs.grid, iniloc = iniloc)
L.mle <- L$L.mle; L <- L$L
par0=c(8.908,10.27,1.152,0.0472,0.707,0.866)
D1 <- par0[1:2] # parameters for kernel 1. this is behavior mode transit
D2 <- par0[3:4] # parameters for kernel 2. resident behavior mode
p <- par0[5:6]
K1 = gausskern(D1[1], D1[2], muadv = 0)
K2 = gausskern(D2[1], D2[2], muadv = 0)
P <- matrix(c(p[1],1-p[1],1-p[2],p[2]),2,2,byrow=TRUE)
#----------------------------------------------------------------------------------#
# RUN THE FILTER STEP
f = hmm.filter(g, L, K1, K2, P)
# plot if you want to see confidence limits
#res = apply(f$phi[1,,,],2:3,sum, na.rm=T)
#fields::image.plot(lon, lat, res/max(res), zlim = c(.05,1))
#----------------------------------------------------------------------------------#
# RUN THE SMOOTHING STEP
s = hmm.smoother(f, K1, K2, P)
T <- dim(s)[2]
meanlat <- apply(apply(s, c(2, 4), sum) * repmat(t(as.matrix(g.mle$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(s, c(2, 3), sum) * repmat(t(as.matrix(g.mle$lon[1,])), T, 1), 1, sum)
#**track <- calc.track(distr, g)**
plot(meanlon,meanlat,type='l')
world(add=T, fill=T, col='grey')
str(s)
T
T <- dim(s)[2]
meanlat <- apply(apply(s, c(2, 4), sum) * repmat(t(as.matrix(g$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(s, c(2, 3), sum) * repmat(t(as.matrix(g$lon[1,])), T, 1), 1, sum)
plot(meanlon,meanlat,type='l')
maptools::world(add=T, fill=T, col='grey')
?world
fields::world(add=T, fill=T, col='grey')
maps::world(add=T, fill=T, col='grey')
library(fields)
