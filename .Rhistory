spot.i
?raster::extract\
?raster::extract
r.ex <- raster::extract(L.ohc[[t]], c(spot.i$lon,spot.i$lat))
r.ex
r.ex <- raster::extract(L.ohc[[t]], matrix(spot.i$lon,spot.i$lat))
r.ex <- raster::extract(L.ohc[[t]], cbind(spot.i$lon,spot.i$lat))
r.ex
plot(L.ohc[[t]])
t=31
spot.idx <- which(spotDates %in% dateVec[t])
spot.idx
spot.i <- spot[min(spot.idx),]
r.ex <- raster::extract(L.ohc[[t]], cbind(spot.i$lon,spot.i$lat))
r.ex
plot(L.ohc[[t]])
points(spot.i$lon,spot.i$lat)
names(df) <- list('dateOnly','lon','lat','extr','mc','rmse')
mc
df <- data.frame(matrix(ncol=7, nrow=T))
names(df) <- list('dateOnly','lon','lat','extr','mc.lon','mc.lat','rmse')
str(df)
str(mc)
df <- data.frame(matrix(ncol=7, nrow=T))
names(df) <- list('dateOnly','lon','lat','extr','mc.lon','mc.lat','rmse')
spotDates <- as.Date(spot$date)
for (t in 1:T){
spot.idx <- which(spotDates %in% dateVec[t])
if(length(spot.idx > 0)){
spot.i <- spot[min(spot.idx),]
r.ex <- raster::extract(L.ohc[[t]], cbind(spot.i$lon,spot.i$lat))
r.pts <- rasterToPoints(L.ohc[[t]], spatial=TRUE)
# generate mean weighted centre at each time T
mc <- mean_centre(weighted=TRUE, weights=as.data.frame(r.pts)[,1], points=as.data.frame(r.pts)[,c(2,3)])
# compare centre of L to day's spot position and do RMSE
df[t,1] <- spot.i$date
df[t,2:3] <- c(spot.i$lon, spot.i$lat)
df[t,4] <- r.ex
df[t,5:6] <- mc[,2:3]
}
}
head(df)
for (t in 1:5){
spot.idx <- which(spotDates %in% dateVec[t])
if(length(spot.idx > 0)){
spot.i <- spot[min(spot.idx),]
r.ex <- raster::extract(L.ohc[[t]], cbind(spot.i$lon,spot.i$lat))
r.pts <- rasterToPoints(L.ohc[[t]], spatial=TRUE)
# generate mean weighted centre at each time T
mc <- mean_centre(weighted=TRUE, weights=as.data.frame(r.pts)[,1], points=as.data.frame(r.pts)[,c(2,3)])
# compare centre of L to day's spot position and do RMSE
df[t,1] <- paste(year(spot.i$date),'-',month(spot.i$date),'-',day(spot.i$date),sep='')
df[t,2:3] <- c(spot.i$lon, spot.i$lat)
df[t,4] <- r.ex
df[t,5:6] <- mc[,2:3]
}
}
df
head(df)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
str()
str(L)
graphics.off()
D1
D2
p
str(F)
str(f)
image.plot(lon,lat,f$phi[1,1,,])
image.plot(lon,lat,f$pred[1,1,,])
par(mfrow=c(2,1))
image.plot(lon,lat,f$phi[1,2,,])
image.plot(lon,lat,f$pred[1,2,,])
points(iniloc[,c(5,4)])
str(s)
image.plot(lon,lat,s[1,1,,])
image.plot(lon,lat,s[2,1,,])
points(iniloc[1,c(5,4)])
K1
K2
P
T <- dim(f$phi)[2]
row <- dim(f$phi)[3]
col <- dim(f$phi)[4]
K1 <- imager::as.cimg(K1)
K2 <- imager::as.cimg(K2)
smooth <- f$phi  #default; fill in as the prediction step.
install.packages('animation')
library(animation)
?animation
?ani.options
str(s)
oopt = ani.options(interval = 0.2, nmax = T)
## use a loop to create images one by one
for (i in T:1) {
image.plot(lon,lat,s[1,i,,])
world(add=T,fill=T)
ani.pause()  ## pause for a while ('interval')
}
oopt = ani.options(interval = 0.2, nmax = 3)
## use a loop to create images one by one
for (i in 1:3) {
image.plot(lon,lat,s[1,i,,])
world(add=T,fill=T)
ani.pause()  ## pause for a while ('interval')
}
## restore the options
ani.options(oopt)
oopt = ani.options(interval = 0.2, nmax = 3)
## use a loop to create images one by one
for (i in 1:3) {
image.plot(lon,lat,s[1,i,,])
#world(add=T,fill=T)
ani.pause()  ## pause for a while ('interval')
}
## restore the options
ani.options(oopt)
oopt = ani.options(interval = 0.2, nmax = 3)
## use a loop to create images one by one
for (i in 1:3) {
image.plot(lon,lat,s[1,i,,])
#world(add=T,fill=T)
ani.pause()  ## pause for a while ('interval')
}
## restore the options
ani.options(oopt)
oopt = ani.options(interval = 0.2, nmax = 3)
## use a loop to create images one by one
for (i in 1:3) {
image.plot(lon,lat,s[1,i,,])
#world(add=T,fill=T)
ani.pause()  ## pause for a while ('interval')
}
## restore the options
ani.options(oopt)
graphics.off()
pdf('mako257_smooth.pdf',width=12,height=8)
for (i in T:1) {
image.plot(lon,lat,s[1,i,,])
world(add=T,fill=T)
title(paste(T))
#ani.pause()  ## pause for a while ('interval')
}
dev.off()
181-22
i=159
image.plot(lon,lat,s[1,i,,])
world(add=T,fill=T)
title(paste(i)))
title(paste(i))
i=i+1
image.plot(lon,lat,s[1,i,,])
world(add=T,fill=T)
title(paste(i))
par(mfrow=c(3,1))
image.plot(lon,lat,L[i,,])
world(add=T,fill=T)
image.plot(lon,lat,f$pred[1,i,,])
world(add=T,fill=T)
title('f$pred')
image.plot(lon,lat,s[1,i,,])
world(add=T,fill=T)
image.plot(lon,lat,s[2,i,,])
world(add=T,fill=T)
title('s[2,i,,]')
world()
world()
image.plot(lon,lat,s[2,i,,])
title('s[2,i,,]')
graphics.off()
par(mfrow=c(2,1))
title('s[2,i,,]')
image.plot(lon,lat,s[2,i,,])
title('s[2,i,,]')
image.plot(lon,lat,s[2,i,,])
graphics.off()
image.plot(lon,lat,s[2,i,,])
par(mfrow=c(2,1))
image.plot(lon,lat,f$phi[1,i,,])
image.plot(lon,lat,f$phi[2,i,,])
image.plot(lon,lat,f$pred[1,i,,])
image.plot(lon,lat,f$pred[2,i,,])
T <- dim(f$phi)[2]
row <- dim(f$phi)[3]
col <- dim(f$phi)[4]
K1 <- imager::as.cimg(K1)
K2 <- imager::as.cimg(K2)
K1
smooth <- f$phi  #default; fill in as the prediction step.
i
for(t in T:162){
RAT <- smooth[,t,,] / (f$pred[,t,,] + 1e-15)
#     Rp1 <- as.vector(K1 %*% as.vector(RAT[1,,]))
#     Rp2 <- as.vector(K2 %*% as.vector(RAT[2,,]))
p1 = imager::as.cimg(t(RAT[1,,]))
Rp1 <- imager::convolve(p1, K1)
p2 = imager::as.cimg(t(RAT[2,,]))
Rp2 <- imager::convolve(p2, K2)
Rp1 = t(as.matrix(Rp1))
Rp2 = t(as.matrix(Rp2))
if(plot){
par(mfrow = c(1,2))
image.plot(Rp1)
#plot(countriesLow,add=T)
image.plot(Rp2)
#plot(countriesLow,add=T)
}
post1 <- matrix(P[1,1] * Rp1 + P[1,2] * Rp2, row, col)
post2 <- matrix(P[2,1] * Rp1 + P[2,2] * Rp2, row, col)
if(T == t){
post1 <- f$phi[1,t,,]
post2 <- f$phi[2,t,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
smooth[1,t,,] <- post1 / fac
smooth[2,t,,] <- post2 / fac
post1 <- post1 * f$phi[1,t-1,,]
post2 <- post2 * f$phi[2,t-1,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
smooth[1,t-1,,] <- post1 / fac
smooth[2,t-1,,] <- post2 / fac
}else{
post1 <- post1 * f$phi[1,t-1,,]
post2 <- post2 * f$phi[2,t-1,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
smooth[1,t-1,,] <- post1 / fac
smooth[2,t-1,,] <- post2 / fac
}
}
t
t=161
RAT <- smooth[,t,,] / (f$pred[,t,,] + 1e-15)
str(RAT)
image.plot(lon,lat,RAT[1,,]])
image.plot(lon,lat,RAT[1,,])
image.plot(lon,lat,RAT[2,,])
t
image.plot(lon,lat,f$phi[1,t,,])
image.plot(lon,lat,RAT[1,,])
image.plot(lon,lat,f$phi[1,t,,])
image.plot(lon,lat,f$phi[2,t,,])
smooth <- f$phi  #default; fill in as the prediction step.
t=T
RAT <- smooth[,t,,] / (f$pred[,t,,] + 1e-15)
image.plot(lon,lat,RAT[1,,])
points(iniloc[2,c(5,4)])
p1 = imager::as.cimg(t(RAT[1,,]))
Rp1 <- imager::convolve(p1, K1)
p2 = imager::as.cimg(t(RAT[2,,]))
Rp2 <- imager::convolve(p2, K2)
Rp1 = t(as.matrix(Rp1))
Rp2 = t(as.matrix(Rp2))
str(Rp1)
image.plot(lon,lat,Rp1)
post1 <- f$phi[1,t,,]
post2 <- f$phi[2,t,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
t
smooth[1,t,,] <- post1 / fac
smooth[2,t,,] <- post2 / fac
image.plot(lon,lat,smooth[1,t,,])
image.plot(lon,lat,smooth[2,t,,])
points(iniloc[2,c(5,4)])
post1 <- post1 * f$phi[1,t-1,,]
post2 <- post2 * f$phi[2,t-1,,]
fac <- sum(as.vector(post1)) + sum(as.vector(post2))
smooth[1,t-1,,] <- post1 / fac
smooth[2,t-1,,] <- post2 / fac
image.plot(lon,lat,smooth[1,t-1,,])
image.plot(lon,lat,smooth[1,t,,])
post1 <- f$phi[1,t,,]
post2 <- f$phi[2,t,,]
post1 <- post1 * f$phi[1,t-1,,]
post2 <- post2 * f$phi[2,t-1,,]
str(post1)
image.plot(lon,lat,post1)
image.plot(lon,lat,post2)
image.plot(lon,lat,f$phi[1,t,,])
image.plot(lon,lat,f$phi[1,t-1,,])
image.plot(lon,lat,f$phi[1,t,,])
world(add=T,fill=T)
title('f$phi[1,181,,] - popup')
points(iniloc[2,c(5,4)])
image.plot(lon,lat,f$phi[1,t-1,,])
world(add=T,fill=T)
title('f$phi[1,180,,] - before pop')
image.plot(lon,lat,f$pred[1,t,,])
world(add=T,fill=T)
title('f$pred[1,181,,] - popup')
points(iniloc[2,c(5,4)])
image.plot(lon,lat,f$pred[1,t-1,,])
world(add=T,fill=T)
title('f$pred[1,180,,] - before pop')
image.plot(lon,lat,L[t-1,,])
world(add=T,fill=T)
title('L[180,,] - before pop')
points(iniloc[2,c(5,4)])
image.plot(lon,lat,f$phi[1,t-1,,])
world(add=T,fill=T)
title('f$phi[1,180,,] - before pop')
image.plot(lon,lat,L[177,,])
world(add=T,fill=T)
image.plot(lon,lat,L[178,,])
world(add=T,fill=T)
image.plot(lon,lat,L[179,,])
world(add=T,fill=T)
image.plot(lon,lat,L[180,,])
world(add=T,fill=T)
T <- dim(L)[1] # dimension of time
row <- dim(g$lon)[1] # nrows
col <- dim(g$lon)[2] # ncols
m <- 2 # Number of behavioural states
pred <- array(0, dim = c(m, T, col, row)) # empty array for prediction step. ordering in col before row emulates lon before lat
phi  <- array(0, dim = c(m, T, col, row)) # posterior (final) step array
# Start in resident state at the known initial location
phi[1,1,,]  <- L[1,,] # first position is known
phi[2,1,,]  <- L[1,,] # first position is known
pred[1,1,,] <- L[1,,] # first position is known
pred[2,1,,] <- L[1,,] # first position is known
psi <- rep(0, T - 1) # sum of the probability of both states at each step
K1 <- imager::as.cimg(K1)
K2 <- imager::as.cimg(K2)
for(t in 2:(T-5)){
# replace this part with older workflow using a gaussian kernel..
# p1 <- as.vector(phi[1,t-1,,])
# p2 <- as.vector(phi[2,t-1,,])
# q1 <- as.vector(p1%*%K1)
# q2 <- as.vector(p2%*%K2)
p1 = imager::as.cimg(t(phi[1, t-1,,]))
p2 = imager::as.cimg(t(phi[2, t-1,,]))
q1 = imager::convolve(p1, K1)
q2 = imager::convolve(p2, K2)
# q1 = arot(t(as.matrix(q1)),3)
# q2 = arot(t(as.matrix(q2)),3)
q1 = t(as.matrix(q1))
q2 = t(as.matrix(q2))
# 	par(mfrow=c(1,2))
# 	image(q1)
# 	image(q2)
# pred[1,t,,] <- matrix(P[1,1]*q1+P[2,1]*q2,row,col)
# pred[2,t,,] <- matrix(P[1,2]*q1+P[2,2]*q2,row,col)
# multiply by transition probability
pred[1,t,,] <- P[1,1] * q1 + P[2,1] * q2
pred[2,t,,] <- P[1,2] * q1 + P[2,2] * q2
sumL = sum(L[t,,])
if(sumL > 0){
post1 <- pred[1,t,,] * L[t,,]
post2 <- pred[2,t,,] * L[t,,]
}else{
post1 <- pred[1,t,,]
post2 <- pred[2,t,,]
}
psi[t-1] <- sum(as.vector(post1), na.rm=T) + sum(as.vector(post2), na.rm=T)
# remove NaNs...
# normalise (divide here by sum, not max)
# 	post1 <- normalise(post1)
# 	post2 <- normalise(post2)
# 	post1[is.nan(post1)] = 0
# 	post2[is.nan(post2)] = 0
phi[1,t,,] <- post1 / (psi[t-1] + 1e-15)
phi[2,t,,] <- post2 / (psi[t-1] + 1e-15)
}
t
image.plot(lon,lat,phi[1,t,,]); world(add=T,fill=T); image.plot(lon,lat,phi[2,t,,]); world(add=T,fill=T)
t=177
p1 = imager::as.cimg(t(phi[1, t-1,,]))
p2 = imager::as.cimg(t(phi[2, t-1,,]))
q1 = imager::convolve(p1, K1)
q2 = imager::convolve(p2, K2)
# q1 = arot(t(as.matrix(q1)),3)
# q2 = arot(t(as.matrix(q2)),3)
q1 = t(as.matrix(q1))
q2 = t(as.matrix(q2))
# 	par(mfrow=c(1,2))
# 	image(q1)
# 	image(q2)
# pred[1,t,,] <- matrix(P[1,1]*q1+P[2,1]*q2,row,col)
# pred[2,t,,] <- matrix(P[1,2]*q1+P[2,2]*q2,row,col)
# multiply by transition probability
pred[1,t,,] <- P[1,1] * q1 + P[2,1] * q2
pred[2,t,,] <- P[1,2] * q1 + P[2,2] * q2
sumL = sum(L[t,,])
if(sumL > 0){
post1 <- pred[1,t,,] * L[t,,]
post2 <- pred[2,t,,] * L[t,,]
}else{
post1 <- pred[1,t,,]
post2 <- pred[2,t,,]
}
psi[t-1] <- sum(as.vector(post1), na.rm=T) + sum(as.vector(post2), na.rm=T)
# remove NaNs...
# normalise (divide here by sum, not max)
# 	post1 <- normalise(post1)
# 	post2 <- normalise(post2)
# 	post1[is.nan(post1)] = 0
# 	post2[is.nan(post2)] = 0
phi[1,t,,] <- post1 / (psi[t-1] + 1e-15)
phi[2,t,,] <- post2 / (psi[t-1] + 1e-15)
image.plot(lon,lat,phi[1,t,,]); world(add=T,fill=T); image.plot(lon,lat,phi[2,t,,]); world(add=T,fill=T)
t=178
p1 = imager::as.cimg(t(phi[1, t-1,,]))
p2 = imager::as.cimg(t(phi[2, t-1,,]))
q1 = imager::convolve(p1, K1)
q2 = imager::convolve(p2, K2)
# q1 = arot(t(as.matrix(q1)),3)
# q2 = arot(t(as.matrix(q2)),3)
q1 = t(as.matrix(q1))
q2 = t(as.matrix(q2))
# 	par(mfrow=c(1,2))
# 	image(q1)
# 	image(q2)
# pred[1,t,,] <- matrix(P[1,1]*q1+P[2,1]*q2,row,col)
# pred[2,t,,] <- matrix(P[1,2]*q1+P[2,2]*q2,row,col)
# multiply by transition probability
pred[1,t,,] <- P[1,1] * q1 + P[2,1] * q2
pred[2,t,,] <- P[1,2] * q1 + P[2,2] * q2
sumL = sum(L[t,,])
if(sumL > 0){
post1 <- pred[1,t,,] * L[t,,]
post2 <- pred[2,t,,] * L[t,,]
}else{
post1 <- pred[1,t,,]
post2 <- pred[2,t,,]
}
psi[t-1] <- sum(as.vector(post1), na.rm=T) + sum(as.vector(post2), na.rm=T)
# remove NaNs...
# normalise (divide here by sum, not max)
# 	post1 <- normalise(post1)
# 	post2 <- normalise(post2)
# 	post1[is.nan(post1)] = 0
# 	post2[is.nan(post2)] = 0
phi[1,t,,] <- post1 / (psi[t-1] + 1e-15)
phi[2,t,,] <- post2 / (psi[t-1] + 1e-15)
image.plot(lon,lat,phi[1,t,,]); world(add=T,fill=T); image.plot(lon,lat,phi[2,t,,]); world(add=T,fill=T)
points(iniloc[2,c(5,4)])
t
t=179
p1 = imager::as.cimg(t(phi[1, t-1,,]))
p2 = imager::as.cimg(t(phi[2, t-1,,]))
q1 = imager::convolve(p1, K1)
q2 = imager::convolve(p2, K2)
# q1 = arot(t(as.matrix(q1)),3)
# q2 = arot(t(as.matrix(q2)),3)
q1 = t(as.matrix(q1))
q2 = t(as.matrix(q2))
# 	par(mfrow=c(1,2))
# 	image(q1)
# 	image(q2)
# pred[1,t,,] <- matrix(P[1,1]*q1+P[2,1]*q2,row,col)
# pred[2,t,,] <- matrix(P[1,2]*q1+P[2,2]*q2,row,col)
# multiply by transition probability
pred[1,t,,] <- P[1,1] * q1 + P[2,1] * q2
pred[2,t,,] <- P[1,2] * q1 + P[2,2] * q2
sumL = sum(L[t,,])
if(sumL > 0){
post1 <- pred[1,t,,] * L[t,,]
post2 <- pred[2,t,,] * L[t,,]
}else{
post1 <- pred[1,t,,]
post2 <- pred[2,t,,]
}
psi[t-1] <- sum(as.vector(post1), na.rm=T) + sum(as.vector(post2), na.rm=T)
# remove NaNs...
# normalise (divide here by sum, not max)
# 	post1 <- normalise(post1)
# 	post2 <- normalise(post2)
# 	post1[is.nan(post1)] = 0
# 	post2[is.nan(post2)] = 0
phi[1,t,,] <- post1 / (psi[t-1] + 1e-15)
phi[2,t,,] <- post2 / (psi[t-1] + 1e-15)
image.plot(lon,lat,phi[1,t,,]); world(add=T,fill=T); image.plot(lon,lat,phi[2,t,,]); world(add=T,fill=T)
?repmat
repmat <- function(X,m,n){
mx = dim(X)[1]
nx = dim(X)[2]
matrix(t(matrix(X,mx,nx*n)),mx*m,nx*n,byrow=T)
}
par0=c(8.908,10.27,1.152,0.0472,0.707,0.866)
D1 <- par0[1:2] # parameters for kernel 1. this is behavior mode transit
D2 <- par0[3:4] # parameters for kernel 2. resident behavior mode
p <- par0[5:6]
K1 = gausskern(D1[1], D1[2], muadv = 0)
K2 = gausskern(D2[1], D2[2], muadv = 0)
P <- matrix(c(p[1],1-p[1],1-p[2],p[2]),2,2,byrow=TRUE)
f = hmm.filter(g.mle, L.mle, K1, K2, P)
s = hmm.smoother_test(f, K1, K2, P, plot = F)
distr = s
meanlat <- apply(apply(distr, c(2, 4), sum) * repmat(t(as.matrix(g$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(distr, c(2, 3), sum) * repmat(t(as.matrix(g$lon[1,])), T, 1), 1, sum)
meanlat <- apply(apply(distr, c(2, 4), sum) * repmat(t(as.matrix(g.mle$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(distr, c(2, 3), sum) * repmat(t(as.matrix(g.mle$lon[1,])), T, 1), 1, sum)
plot(meanlon,meanlat,type='l')
graphics.off()
plot(meanlon,meanlat,type='l')
world(add=T)
lines(spot$lon,spot$lat,col='blue')
str(s)
D1 <- par0[1:2]/4 # parameters for kernel 1. this is behavior mode transit
D2 <- par0[3:4]/4 # parameters for kernel 2. resident behavior mode
K1 = gausskern(D1[1], D1[2], muadv = 0)
K2 = gausskern(D2[1], D2[2], muadv = 0)
P <- matrix(c(p[1],1-p[1],1-p[2],p[2]),2,2,byrow=TRUE)
f = hmm.filter(g.mle, L.mle, K1, K2, P)
s = hmm.smoother_test(f, K1, K2, P, plot = F)
distr = s
meanlat <- apply(apply(distr, c(2, 4), sum) * repmat(t(as.matrix(g$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(distr, c(2, 3), sum) * repmat(t(as.matrix(g$lon[1,])), T, 1), 1, sum)
meanlat <- apply(apply(distr, c(2, 4), sum) * repmat(t(as.matrix(g.mle$lat[,1])), T, 1), 1, sum)
meanlon <- apply(apply(distr, c(2, 3), sum) * repmat(t(as.matrix(g.mle$lon[1,])), T, 1), 1, sum)
plot(meanlon,meanlat,type='l')
world(add=T, fill=T, col='grey')
D1
D2
