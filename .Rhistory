dateidx <- which(format(pdt$Date, '%Y-%m-%d') == udates)
dateidx
pdt$MinTemp <= isotherm
isotherm = 10
pdt$MinTemp <= isotherm
head(udates)
dates.tr <- format(pdt$Date, '%Y-%m-%d')
head(dates.tr)
udates %in% dates.tr
dates.tr %in% udates
?match
match(dates.tr, udates)
pdt[which(dateidx==1),]
dateidx
dateidx <- match(dates.tr, udates)
pdt[which(dateidx==1),]
i=1
pdt.i <- pdt[which(dateidx == i),]
pdt.i
length(which(pdt.i$BinNum == 1)) > 1
pdt.i <- pdt.i[order(pdt.i$Depth),]
pdt.i
unique(pdt.i$Depth)
?approx
approx(pdt.i$Depth, pdt.i$MinTemp, xout = unique(pdt.i$Depth))
z <- unique(pdt.i$Depth)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)
maxT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)
cbind(z,minT,maxT)
minT
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
cbind(z,minT,maxT)
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
cbind(z,minT,maxT)
pdt.i
pdt.t <- pdt.i[1:length(z),]#cbind(z,minT,maxT)
pdt.t
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t
pdt.t[,2] <- paste(format(pdt.i$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
pdt.t
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
pdt.t
extract.pdt = function(data){
# extract PDT data from WC tag output
# need to convert to long format for use in R
#' @param: data is data frame read from .csv output of Wildlife Computers
#' DAP processor. File ends in "-PDTs.csv"
#'
#' @return: pdt is formatted data frame of pdt data
# eliminate any oxygen data
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
# convert to long format
vars = names(data[,c(which(names(data) == 'Depth1'):length(names(data)))])
pdt <- reshape(data, ids = data$Date, direction = 'long',
varying = vars, times = vars, sep='', timevar = 'BinNum')
keepNames = c('Ptt', 'Date', 'NumBins', 'BinNum', 'Depth', 'MinTemp', 'MaxTemp')
pdt <- pdt[,c(keepNames)]
row.names(pdt) <- NULL
# date conversion then sort
pdt$Date <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
pdt <- pdt[order(pdt$Date, pdt$Depth),]
#pdt <- pdt[which(!is.na(pdt$Depth)),]
pdt <- pdt[!is.na(pdt$Depth),]
udates <- unique(format(pdt$Date, '%Y-%m-%d'))
dates.tr <- format(pdt$Date, '%Y-%m-%d')
dateidx <- match(dates.tr, udates)
for(i in 1:max(dateidx)){
pdt.i <- pdt[which(dateidx == i),]
if(length(which(pdt.i$BinNum == 1)) > 1){
pdt.i <- pdt.i[order(pdt.i$Depth),]
z <- unique(pdt.i$Depth)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
} else{pdt.t <- pdt.i}
if(i == 1) pdtNew <- pdt.t else pdtNew <- rbind(pdtNew, pdt.t)
}
# write out / return
return(pdt)
}
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
pdt <- extract.pdt(pdt)
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
data <- pdt
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
# convert to long format
vars = names(data[,c(which(names(data) == 'Depth1'):length(names(data)))])
pdt <- reshape(data, ids = data$Date, direction = 'long',
varying = vars, times = vars, sep='', timevar = 'BinNum')
keepNames = c('Ptt', 'Date', 'NumBins', 'BinNum', 'Depth', 'MinTemp', 'MaxTemp')
pdt <- pdt[,c(keepNames)]
row.names(pdt) <- NULL
# date conversion then sort
pdt$Date <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
pdt <- pdt[order(pdt$Date, pdt$Depth),]
#pdt <- pdt[which(!is.na(pdt$Depth)),]
pdt <- pdt[!is.na(pdt$Depth),]
udates <- unique(format(pdt$Date, '%Y-%m-%d'))
dates.tr <- format(pdt$Date, '%Y-%m-%d')
dateidx <- match(dates.tr, udates)
dateidx
i=1
pdt.i <- pdt[which(dateidx == i),]
pdt.i
if(length(which(pdt.i$BinNum == 1)) > 1){
pdt.i <- pdt.i[order(pdt.i$Depth),]
z <- unique(pdt.i$Depth)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
}
pdt.t
for(i in 1:max(dateidx)){
pdt.i <- pdt[which(dateidx == i),]
if(length(which(pdt.i$BinNum == 1)) > 1){
pdt.i <- pdt.i[order(pdt.i$Depth),]
z <- unique(pdt.i$Depth)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
} else{pdt.t <- pdt.i}
if(i == 1) pdtNew <- pdt.t else pdtNew <- rbind(pdtNew, pdt.t)
print(i)
}
i=38
pdt.i <- pdt[which(dateidx == i),]
pdt.i
length(pdt.i[,1]) <= 2
for(i in 1:max(dateidx)){
pdt.i <- pdt[which(dateidx == i),]
if(length(pdt.i[,1]) <= 2) break
if(length(which(pdt.i$BinNum == 1)) > 1){
pdt.i <- pdt.i[order(pdt.i$Depth),]
z <- unique(pdt.i$Depth)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
} else{pdt.t <- pdt.i}
if(i == 1) pdtNew <- pdt.t else pdtNew <- rbind(pdtNew, pdt.t)
print(i)
}
pdtNew
dateidx
i=5
pdt.i <- pdt[which(dateidx == i),]
pdt.i
z <- unique(pdt.i$Depth)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
pdt.t
z
z <- order(unique(pdt.i$Depth))
z
z <- unique(pdt.i$Depth); z <- order(z)
z
?sort
z <- unique(pdt.i$Depth); z <- sort(z)
z
pdt.i
pdt.i <- pdt.i[order(pdt.i$Depth),]
pdt.i
z <- unique(pdt.i$Depth)#; z <- sort(z)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
pdt.t
plot(pdt.t$MinTemp,pdt.t$Depth,type='l')
pdtNew
z
tail(dateidx)
i=39
pdt.i <- pdt[which(dateidx == i),]
pdt.i
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
setwd('~/Documents/WHOI/RData/Swords/2013/106795/')
ptt <- 106795
iniloc <- data.frame(matrix(c(27, 9, 2013, 46.47683333, -45.5640,
2, 11, 2013, 30.92645, -39.6919), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
pdt <- extract.pdt(pdt)
data <- pdt
# eliminate any oxygen data
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
# convert to long format
vars = names(data[,c(which(names(data) == 'Depth1'):length(names(data)))])
pdt <- reshape(data, ids = data$Date, direction = 'long',
varying = vars, times = vars, sep='', timevar = 'BinNum')
keepNames = c('Ptt', 'Date', 'NumBins', 'BinNum', 'Depth', 'MinTemp', 'MaxTemp')
pdt <- pdt[,c(keepNames)]
row.names(pdt) <- NULL
# date conversion then sort
pdt$Date <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
pdt <- pdt[order(pdt$Date, pdt$Depth),]
#pdt <- pdt[which(!is.na(pdt$Depth)),]
pdt <- pdt[!is.na(pdt$Depth),]
udates <- unique(format(pdt$Date, '%Y-%m-%d'))
dates.tr <- format(pdt$Date, '%Y-%m-%d')
dateidx <- match(dates.tr, udates)
for(i in 1:max(dateidx)){
pdt.i <- pdt[which(dateidx == i),]
if(length(unique(pdt.i[,5])) <= 2) break
if(length(which(pdt.i$BinNum == 1)) > 1){
pdt.i <- pdt.i[order(pdt.i$Depth),]
z <- unique(pdt.i$Depth)#; z <- sort(z)
z[z < 0] = 0
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
} else{pdt.t <- pdt.i}
if(i == 1) pdtNew <- pdt.t else pdtNew <- rbind(pdtNew, pdt.t)
print(i)
}
pdtNew
z
data <- pdt
# eliminate any oxygen data
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
# convert to long format
vars = names(data[,c(which(names(data) == 'Depth1'):length(names(data)))])
pdt <- reshape(data, ids = data$Date, direction = 'long',
varying = vars, times = vars, sep='', timevar = 'BinNum')
keepNames = c('Ptt', 'Date', 'NumBins', 'BinNum', 'Depth', 'MinTemp', 'MaxTemp')
pdt <- pdt[,c(keepNames)]
row.names(pdt) <- NULL
# date conversion then sort
pdt$Date <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
pdt <- pdt[order(pdt$Date, pdt$Depth),]
#pdt <- pdt[which(!is.na(pdt$Depth)),]
pdt <- pdt[!is.na(pdt$Depth),]
udates <- unique(format(pdt$Date, '%Y-%m-%d'))
dates.tr <- format(pdt$Date, '%Y-%m-%d')
dateidx <- match(dates.tr, udates)
## THIS SECTION NEEDS WORK. CURRENTLY USING MULTIPLE POINTS PER DAY
## TO CONSTRUCT A SINGLE PDT PROFILE. MOSTLY WORKS WELL BUT IN SOME
## CASES THE ANIMAL USES VERY DISTINCT WATER MASSES CAUSING THIS
## AVERAGING TECHNIQUE TO DO WEIRD THINGS AND CONSTRUCT UNREALISTIC
## PROFILES
for(i in 1:max(dateidx)){
pdt.i <- pdt[which(dateidx == i),]
if(length(unique(pdt.i[,5])) <= 2) break
if(length(which(pdt.i$BinNum == 1)) > 1){
pdt.i <- pdt.i[order(pdt.i$Depth),]
z <- unique(pdt.i$Depth)#; z <- sort(z)
z[z < 0] = 0; z <- unique(z)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
} else{pdt.t <- pdt.i}
if(i == 1) pdtNew <- pdt.t else pdtNew <- rbind(pdtNew, pdt.t)
print(i)
}
str(data)
str(pdt)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
setwd('~/Documents/WHOI/RData/Swords/2013/106795/')
ptt <- 106795
iniloc <- data.frame(matrix(c(27, 9, 2013, 46.47683333, -45.5640,
2, 11, 2013, 30.92645, -39.6919), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
pdt <- extract.pdt(pdt)
pdt
str(pdt)
# eliminate any oxygen data
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
# convert to long format
vars = names(data[,c(which(names(data) == 'Depth1'):length(names(data)))])
pdt <- reshape(data, ids = data$Date, direction = 'long',
varying = vars, times = vars, sep='', timevar = 'BinNum')
keepNames = c('Ptt', 'Date', 'NumBins', 'BinNum', 'Depth', 'MinTemp', 'MaxTemp')
pdt <- pdt[,c(keepNames)]
row.names(pdt) <- NULL
# date conversion then sort
pdt$Date <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
pdt <- pdt[order(pdt$Date, pdt$Depth),]
#pdt <- pdt[which(!is.na(pdt$Depth)),]
pdt <- pdt[!is.na(pdt$Depth),]
udates <- unique(format(pdt$Date, '%Y-%m-%d'))
dates.tr <- format(pdt$Date, '%Y-%m-%d')
dateidx <- match(dates.tr, udates)
## THIS SECTION NEEDS WORK. CURRENTLY USING MULTIPLE POINTS PER DAY
## TO CONSTRUCT A SINGLE PDT PROFILE. MOSTLY WORKS WELL BUT IN SOME
## CASES THE ANIMAL USES VERY DISTINCT WATER MASSES CAUSING THIS
## AVERAGING TECHNIQUE TO DO WEIRD THINGS AND CONSTRUCT UNREALISTIC
## PROFILES
# calculate light-based likelihood
setwd('~/Documents/WHOI/RData/Swords/2013/106795/')
ptt <- 106795
iniloc <- data.frame(matrix(c(27, 9, 2013, 46.47683333, -45.5640,
2, 11, 2013, 30.92645, -39.6919), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
data <- pdt
# eliminate any oxygen data
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
# convert to long format
vars = names(data[,c(which(names(data) == 'Depth1'):length(names(data)))])
pdt <- reshape(data, ids = data$Date, direction = 'long',
varying = vars, times = vars, sep='', timevar = 'BinNum')
keepNames = c('Ptt', 'Date', 'NumBins', 'BinNum', 'Depth', 'MinTemp', 'MaxTemp')
pdt <- pdt[,c(keepNames)]
row.names(pdt) <- NULL
# date conversion then sort
pdt$Date <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
pdt <- pdt[order(pdt$Date, pdt$Depth),]
#pdt <- pdt[which(!is.na(pdt$Depth)),]
pdt <- pdt[!is.na(pdt$Depth),]
udates <- unique(format(pdt$Date, '%Y-%m-%d'))
dates.tr <- format(pdt$Date, '%Y-%m-%d')
dateidx <- match(dates.tr, udates)
## THIS SECTION NEEDS WORK. CURRENTLY USING MULTIPLE POINTS PER DAY
## TO CONSTRUCT A SINGLE PDT PROFILE. MOSTLY WORKS WELL BUT IN SOME
## CASES THE ANIMAL USES VERY DISTINCT WATER MASSES CAUSING THIS
## AVERAGING TECHNIQUE TO DO WEIRD THINGS AND CONSTRUCT UNREALISTIC
## PROFILES
pdt
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
# calculate light-based likelihood
setwd('~/Documents/WHOI/RData/Swords/2013/106795/')
ptt <- 106795
iniloc <- data.frame(matrix(c(27, 9, 2013, 46.47683333, -45.5640,
2, 11, 2013, 30.92645, -39.6919), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
pdt <- extract.pdt(pdt)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
pdt <- extract.pdt(pdt)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
pdt <- extract.pdt(pdt)
pdt <- extract.pdt(pdt)
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
pdt <- extract.pdt(pdt)
pdt <- extract.pdt(pdt)
debug(pdt <- extract.pdt(pdt))
data <- pdt
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
# convert to long format
vars = names(data[,c(which(names(data) == 'Depth1'):length(names(data)))])
pdt <- reshape(data, ids = data$Date, direction = 'long',
varying = vars, times = vars, sep='', timevar = 'BinNum')
keepNames = c('Ptt', 'Date', 'NumBins', 'BinNum', 'Depth', 'MinTemp', 'MaxTemp')
pdt <- pdt[,c(keepNames)]
row.names(pdt) <- NULL
# date conversion then sort
pdt$Date <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
pdt <- pdt[order(pdt$Date, pdt$Depth),]
#pdt <- pdt[which(!is.na(pdt$Depth)),]
pdt <- pdt[!is.na(pdt$Depth),]
udates <- unique(format(pdt$Date, '%Y-%m-%d'))
dates.tr <- format(pdt$Date, '%Y-%m-%d')
dateidx <- match(dates.tr, udates)
for(i in 1:max(dateidx)){
pdt.i <- pdt[which(dateidx == i),]
print(pdt.i)
if(length(unique(pdt.i[,5])) <= 2){ print(i,' 1')#break
} else{
print(i,' 2')
if(length(which(pdt.i$BinNum == 1)) > 1){
print(i,' 3')
pdt.i <- pdt.i[order(pdt.i$Depth),]
z <- unique(pdt.i$Depth)#; z <- sort(z)
z[z < 0] = 0; z <- unique(z)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
} else{
print(i,' 4')
pdt.t <- pdt.i
}
if(i == 1) pdtNew <- pdt.t else pdtNew <- rbind(pdtNew, pdt.t)
print(i,' 5')
}
}
i=38
pdt.i <- pdt[which(dateidx == i),]
pdt.i
length(unique(pdt.i[,5])) <= 2
i=39
extract.pdt = function(data){
# extract PDT data from WC tag output
# need to convert to long format for use in R
#' @param: data is data frame read from .csv output of Wildlife Computers
#' DAP processor. File ends in "-PDTs.csv"
#'
#' @return: pdt is formatted data frame of pdt data
# eliminate any oxygen data
if(any(grep('X.Ox', colnames(data)))){
dropidx <- c(grep('Ox', names(data)), grep('Disc', names(data)))
data <- data[,-dropidx]
}
# convert to long format
vars = names(data[,c(which(names(data) == 'Depth1'):length(names(data)))])
pdt <- reshape(data, ids = data$Date, direction = 'long',
varying = vars, times = vars, sep='', timevar = 'BinNum')
keepNames = c('Ptt', 'Date', 'NumBins', 'BinNum', 'Depth', 'MinTemp', 'MaxTemp')
pdt <- pdt[,c(keepNames)]
row.names(pdt) <- NULL
# date conversion then sort
pdt$Date <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
pdt <- pdt[order(pdt$Date, pdt$Depth),]
#pdt <- pdt[which(!is.na(pdt$Depth)),]
pdt <- pdt[!is.na(pdt$Depth),]
udates <- unique(format(pdt$Date, '%Y-%m-%d'))
dates.tr <- format(pdt$Date, '%Y-%m-%d')
dateidx <- match(dates.tr, udates)
## THIS SECTION NEEDS WORK. CURRENTLY USING MULTIPLE POINTS PER DAY
## TO CONSTRUCT A SINGLE PDT PROFILE. MOSTLY WORKS WELL BUT IN SOME
## CASES THE ANIMAL USES VERY DISTINCT WATER MASSES CAUSING THIS
## AVERAGING TECHNIQUE TO DO WEIRD THINGS AND CONSTRUCT UNREALISTIC
## PROFILES
for(i in 1:max(dateidx)){
pdt.i <- pdt[which(dateidx == i),]
print(pdt.i)
if(length(unique(pdt.i[,5])) <= 2){ print(i,' 1')#break
} else{
print(i,' 2')
if(length(which(pdt.i$BinNum == 1)) > 1){
print(i,' 3')
pdt.i <- pdt.i[order(pdt.i$Depth),]
z <- unique(pdt.i$Depth)#; z <- sort(z)
z[z < 0] = 0; z <- unique(z)
minT <- approx(pdt.i$Depth, pdt.i$MinTemp, xout = z)$y
maxT <- approx(pdt.i$Depth, pdt.i$MaxTemp, xout = z)$y
pdt.t <- pdt.i[1:length(z),]
pdt.t[,c(5:7)] <- cbind(z,minT,maxT)
pdt.t[,4] <- seq(1, length(z), by = 1)
pdt.t[,3] <- length(z)
pdt.t[,2] <- paste(format(pdt.t$Date, '%Y-%m-%d'),' 00:00:00', sep = '')
} else{
print(i,' 4')
pdt.t <- pdt.i
}
if(i == 1) pdtNew <- pdt.t else pdtNew <- rbind(pdtNew, pdt.t)
print(i,' 5')
}
}
# write out / return
return(pdtNew)
}
setwd('~/Documents/WHOI/RData/Swords/2013/106795/')
ptt <- 106795
iniloc <- data.frame(matrix(c(27, 9, 2013, 46.47683333, -45.5640,
2, 11, 2013, 30.92645, -39.6919), nrow = 2, ncol = 5, byrow = T))
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 2)
pdt <- extract.pdt(pdt)
tail(pdt)
pdt
