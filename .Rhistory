}
##
# PDT / WOA
##
# set limits of interest
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
# check woa data
graphics.off()
image.plot(lon,lat,dat[,,1,1])
# perform matching
# 'stack' makes the end of this routine much slower than 'brick' or 'array'
# but is only 10 extra seconds or so
L.pdt <- calc.pdt(pdt, dat, lat, lon, raster = 'stack', dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
data(countriesLow)
plot(L.pdt[[100]])
plot(countriesLow, add = T)
plot = FALSE
if(plot){
plot.woa(as.array(L.pdt), return.woa, paste(ptt, '_woalik.pdf', sep=''), pdt = pdt, write.dir = getwd())
}
##
# Light-based Longitude Likelihood (ellipse error is a work in progress)
##
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > tag & dts < pop
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = 'stack', dateVec = dateVec)
# try quick plot to check, if raster = 'stack' or 'brick' above
plot(L.locs[[2]])
plot(countriesLow, add = T)
L.pdt <- spatial_sync_raster(L.pdt, L.locs)
plot(L.pdt[[4]])
plot(countriesLow, add = T)
# multiply daily likelihood matrices
T <- dim(L.pdt)[3]
for(i in 2:(T-1)){
r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
# add known tag/pop locations
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
# cut out days for which no pdt/loc data exists
dateIdx <- sort(unique(c(which(dateVec %in% as.Date(pdt$Date)), c(1,which(dateVec %in% as.Date(locs$Date)),T))))
s.sub <- subset(s, dateIdx)
s.sub
plot(s.sub[[1]])
plot(countriesLow,add=TRUE)
plot(s.sub[[2]])
plot(countriesLow,add=TRUE)
plot(s.sub[[3]])
plot(countriesLow,add=TRUE)
NaN * 3
any(s.sub[[3]] != 0)
any(matrix(s.sub[[3]]) != 0)
any(as.matrix(s.sub[[3]]) != 0)
s.sub[[3]]
any(!is.na(s.sub[[3]]))# != 0)
any(!is.na(as.matrix(s.sub[[3]])))# != 0)
any(!is.na(as.matrix(s.sub[[2]])))# != 0)
any(!is.na(as.matrix(s.sub)))# != 0)
length(c(2:(T-1)))
T
idx <- vector(0,length=T-2)
?vector
idx <- as.vector(0,length=T-2)
idx <- vector('logical',length=T-2)
for(i in 2:(T-1)){
idx[i-1] <- any(!is.na(as.matrix(s.sub[[i]])))# != 0)
}
i
s.sub
idx.pdt <- vector('logical', length = T - 2)
idx.locs <- vector('logical', length = T - 2)
idx.pdt <- vector('logical', length = T - 2)
idx.locs <- vector('logical', length = T - 2)
for(i in 2:(T-1)){
idx.pdt[i - 1] <- any(!is.na(as.matrix(L.pdt[[i]])))
idx.locs[i - 1] <- any(!is.na(as.matrix(L.locs[[i]])))
}
idx.pdt
idx.locs
i=2
idx.locs[i]
idx.pdt[i]
which(idx.locs | idx.pdt)
which(idx.locs[i] | idx.pdt[i])
which(idx.pdt[i] | idx.locs[i])
which(idx.pdt[i] & idx.locs[i])
c(idx.locs[i], idx.pdt[i])
idx1 <- c(idx.locs[i], idx.pdt[i])
idx1[1] & idx1[2]
which(idx1)
which(idx.pdt & idx.locs)
which(idx.pdt)
which(idx.locs)
idx <- which(c(idx.locs[i], idx.pdt[i]))
j
i
idx
i=3
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
idx == c(1,2)
sum(idx) == 3
sum(idx) == 2
for(i in 2:(T-1)){
idx <- which(c(idx.locs[i], idx.pdt[i]))
if(sum(idx) == 3){
r <- L.pdt[[i]] * L.locs[[i]]
} else if(sum(idx) == 2){
r <- L.pdt[[i]]
} else if(sum(idx) == 1){
r <- L.locs[[i]]
}
# r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
s
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
s
plot(s)
plot(s[[1]])
plot(countriesLow,add=T)
plot(s[[2]])
plot(countriesLow,add=T)
plot(s[[5]])
plot(s[[4]])
plot(countriesLow,add=T)
i=5
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
plot(L.pdt[[5]])
plot(L.locs[[5]])
L.locs[[5]]
dateVec[5]
locs[5,]
locs[4,]
locs[4,]
locs[3,]
locs[2,]
any(!is.na(as.matrix(L.locs[[5]])))
idx.locs
idx.pdt <- vector('logical', length = T)
idx.locs <- vector('logical', length = T)
for(i in 2:(T-1)){
idx.pdt[i] <- any(!is.na(as.matrix(L.pdt[[i]])))
idx.locs[i] <- any(!is.na(as.matrix(L.locs[[i]])))
}
idx.locs
i=2
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
plot(L.pdt[[2]])
plot(L.locs[[2]])
i=3
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
plot(L.pdt[[2]])
plot(L.pdt[[3]])
plot(L.locs[[3]])
for(i in 2:(T-1)){
idx <- which(c(idx.locs[i], idx.pdt[i]))
if(sum(idx) == 3){
r <- L.pdt[[i]] * L.locs[[i]]
} else if(sum(idx) == 2){
r <- L.pdt[[i]]
} else if(sum(idx) == 1){
r <- L.locs[[i]]
}
# r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
s
plot(s[[1]])
plot(s[[2]])
plot(s[[3]])
plot(s[[4]])
cbind(idx.pdt,idx.locs)
i=1
idx <- which(c(idx.locs[i], idx.pdt[i]))
idx
sum(idx)
dateIdx <- 0
for(i in 2:(T-1)){
idx <- which(c(idx.locs[i], idx.pdt[i]))
if(sum(idx) == 3){
r <- L.pdt[[i]] * L.locs[[i]]
} else if(sum(idx) == 2){
r <- L.pdt[[i]]
} else if(sum(idx) == 1){
r <- L.locs[[i]]
} else if(sum(idx) == 0){
dateIdx = c(dateIdx, i)
}
# r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
dateIdx
c(1,181) %in% seq(1:T)
which(c(1,181) %in% seq(1:T))
which(seq(1:T) %in% c(1,181))
which(seq(1:T) !%in% c(1,181))
(seq(1:T) !%in% c(1,181))
(seq(1:T) %in% c(1,181))
!(seq(1:T) %in% c(1,181))
which(!(seq(1:T) %in% c(1,181)))
!(seq(1:T) %in% dateIdx)
which(!(seq(1:T) %in% dateIdx))
s.sub <- subset(s, which(!(seq(1:T) %in% dateIdx)))
s
s.sub
plot(s.sub[[1]])
plot(s.sub[[19]])
plot(s.sub[[20]])
dateVec[19]
locs
cbind(idx.pdt,idx.locs)
dateVec[19]
pdt
pdt[1:100,]
pdt[1:150,]
dateVec[19]
plot(L.pdt[[19]])
L.pdt[[19]]
L.locs[[2]]
L.locs[[3]]
any(L.pdt[[19]] != 0)
any(as.matrix(L.pdt[[19]] != 0))
idx.pdt <- vector('logical', length = T)
idx.locs <- vector('logical', length = T)
for(i in 2:(T-1)){
idx.pdt[i] <- any(as.matrix(L.pdt[[i]]) != )
idx.locs[i] <- any(!is.na(as.matrix(L.locs[[i]])))
}
for(i in 2:(T-1)){
idx.pdt[i] <- any(as.matrix(L.pdt[[i]]) != 0)
idx.locs[i] <- any(!is.na(as.matrix(L.locs[[i]])))
}
dateIdx <- 0
for(i in 2:(T-1)){
idx <- which(c(idx.locs[i], idx.pdt[i]))
if(sum(idx) == 3){
r <- L.pdt[[i]] * L.locs[[i]]
} else if(sum(idx) == 2){
r <- L.pdt[[i]]
} else if(sum(idx) == 1){
r <- L.locs[[i]]
} else if(sum(idx) == 0){
dateIdx = c(dateIdx, i)
}
# r <- L.pdt[[i]] * L.locs[[i]]
if(i == 2){
s <- stack(r)
} else{
s <- stack(s, r)
}
}
tagL <- spatial_sync_raster(L.locs[[1]], s)
popL <- spatial_sync_raster(L.locs[[T]], s)
s <- stack(tagL, s, popL)
which(!(seq(1:T) %in% dateIdx))
s.sub <- subset(s, which(!(seq(1:T) %in% dateIdx)))
s.sub
plot(s.sub[[18]])
plot(s.sub[[19]])
plot(s.sub[[21]])
T <- dim(s.sub)[3]
T
L <- aperm(s.sub, c(3,2,1))
str(as.array(s.sub))
s.sub
L <- aperm(as.array(s.sub), c(3,2,1))
image.plot(lon,lat,L[3,,])
str(lon)
str(lat)
image.plot(lon,lat,t(L[3,,]))
L <- aperm(as.array(flip(s.sub, direction = 'y')), c(3,2,1))
image.plot(lon,lat,t(L[3,,]))
image.plot(lon,lat,L[3,,])
image.plot(lon, lat, L[4,,])
image.plot(lon, lat, L[3,,])
T <- dim(L)[1]
T
par0=c(8.908,10.27,1.152,0.0472,0.707,0.866)
D1 <- par0[1:2]
D2 <- par0[3:4]
p <- par0[5:6]
str(g)
G1 <- make.kern(D1,g)
dt
dt <- 1
K1 <- uniformization(G1,dt)
tr <- read.table(paste(ptt,'-SPOT.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
str(tr)
tr <- tr[,c(4, 7, 8)]
tr$b <- 1 # set an arbitrary state at this point
str(tr)
tag
pop
dts <- as.POSIXct(tr$date, format = findDateFormat(tr$date))
dts <- as.POSIXct(tr$date, format = '%m/%d/%y %H:%M')
str(tr)
colnames(tr) <- list('date','lat','lon','b')
dts <- as.POSIXct(tr$date, format = findDateFormat(tr$date))#'%m/%d/%y %H:%M')
head(dts)
didx <- dts >= tag & dts <= pop
tr <- tr[didx,]
str(tr)
plot(tr$lon,tr$lat,type='l')
devtools::load_all("~/Documents/WHOI/RCode/hmmwoa")
calc.pdt
devtools::load_all(".")
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
didx <- dts >= tag & dts <= pop
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
i=1
time <- as.Date(udates[i])
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat; lon = return.woa$lon; lat = return.woa$lat; depth = return.woa$depth
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
# check woa data
graphics.off()
image.plot(lon,lat,dat[,,1,1])
# perform matching
# 'stack' makes the end of this routine much slower than 'brick' or 'array'
# but is only 10 extra seconds or so
L.pdt <- calc.pdt(pdt, dat, lat, lon, raster = 'stack', dateVec = dateVec)
data(countriesLow)
plot(L.pdt[[4]])
plot(countriesLow, add = T)
?spatial_sync_raster
devtools::load_all(".")
devtools::load_all(".")
ptt <- 121325
iniloc <- data.frame(matrix(c(3, 3, 2013, 30.3917, -81.3802,
31, 8, 2013, 30.668, -79.972), nrow = 2, ncol = 5, byrow = T))
colnames(iniloc) = list('day','month','year','lat','lon')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
setwd('~/Documents/WHOI/RData/WhiteSharks/2013/121325/')
pdt <- read.table(paste(ptt,'-PDTs.csv', sep=''), sep=',',header=T,blank.lines.skip=F, skip = 0)
pdt <- extract.pdt(pdt)
tag <- as.POSIXct(paste(iniloc[1,1], '/', iniloc[1,2], '/', iniloc[1,3], sep=''), format = '%d/%m/%Y')
pop <- as.POSIXct(paste(iniloc[2,1], '/', iniloc[2,2], '/', iniloc[2,3], sep=''), format = '%d/%m/%Y')
dts <- as.POSIXct(pdt$Date, format = findDateFormat(pdt$Date))
didx <- dts >= tag & dts <= pop
pdt <- pdt[didx,]
lon = c(-90, -40)
lat = c(10, 55)
udates <- unique(as.Date(pdt$Date))
dateVec <- as.Date(seq(tag, pop, by = 'day'))
limits = c(lon, lat) # (min lon, max lon, min lat, max lat)
woa.dir = '/Users/Cam/Documents/WHOI/RData/pdtMatch/WOA_25deg/global/'
return.woa = extract.woa(woa.dir, limits, resolution = 'quarter')
dat = return.woa$dat;
lon = as.numeric(return.woa$lon);
lat = as.numeric(return.woa$lat);
depth = as.numeric(return.woa$depth)
# eliminate Pacific from woa data
dat = removePacific(dat, lat, lon)
# check woa data
graphics.off()
image.plot(lon,lat,dat[,,1,1])
L.pdt <- calc.pdt(pdt, dat, lat, lon, raster = 'stack', dateVec = dateVec)
data(countriesLow)
plot(L.pdt[[100]])
plot(countriesLow, add = T)
locs <- read.table(paste(ptt, '-Locations.csv', sep=''), sep=',', header = T, blank.lines.skip = F)
dts <- format(as.POSIXct(locs$Date, format = findDateFormat(locs$Date)), '%Y-%m-%d')
didx <- dts > tag & dts < pop
locs <- locs[didx,]
g <- setup.grid(locs, res = 'quarter') # make sure loading function from misc_funs.r
ngrid <- rev(dim(g$lon))
lon <- g$lon[1,]
lat <- g$lat[,1]
L.locs <- calc.locs(locs, iniloc, g, raster = T, dateVec = dateVec)
plot(L.locs[[2]])
plot(countriesLow, add = T)
plot(L.locs[[2]]*L.pdt[[2]])
plot(countriesLow, add = T)
L.pdt <- spatial_sync_raster(L.pdt, L.locs)
library(spatial.tools)
L.pdt <- spatial_sync_raster(L.pdt, L.locs)
plot(L.pdt[[4]])
plot(countriesLow, add = T)
L.locs = as.array(L.locs)
L.pdt = as.array(L.pdt)
L.locs[is.na(L.locs)] = 0
L.pdt[is.na(L.pdt)] = 0
nalocidx = apply(L.locs,3, sum, na.rm=T)==0
napdtidx = apply(L.pdt,3, sum, na.rm=T)==0
naLidx = nalocidx+napdtidx # where both are zeros. These will be interpolted in the filter
dateIdx = naLidx==0 # may not need this but here for now..
Lmat = L.pdt*0
idx1 = naLidx==1
idx2 = naLidx==2
Lmat[,,idx1] = L.pdt[,,idx1]+L.locs[,,idx1]
Lmat[,,idx2] = L.pdt[,,idx2]*L.locs[,,idx2]
L <- aperm(Lmat, c(3,2,1))  # using arrays..
image.plot(lon, lat, L[3,,])
T <- dim(L)[1]
T
par0=c(8.908,10.27,1.152,0.0472,0.707,0.866)
D1 <- par0[1:2]
D2 <- par0[3:4]
p <- par0[5:6]
dt <- 1
G1 <- make.kern(D1,g)
K1 <- uniformization(G1,dt)
str(G1)
str(g)
diag(G1)
str(g)
str(G1)
A <- G1
dt <- g
N <- dim(A)[1]
# Find the numerical largest rate
F <- -min(diag(A))
# Calculate number of iterations based expression in Grassmann 1977, eq 10
m <- ceiling(F*dt + 4*sqrt(F*dt) + 5)
dt=1
m <- ceiling(F*dt + 4*sqrt(F*dt) + 5)
# Insert warning if m>140 ??
#I <- spMatrix(N,N,i=1:N,j=1:N,rep(1,N))
I <- Diagonal(N)
#I <- diag(N)
P <- A/F + I # Create sub-stochastic matrix (eq 8)
S <- I
pt <- I
FPdt <- F*P*dt
for(i in 1:m){
S <- S %*% FPdt
fact <- exp(lgamma(i+1))
pt <- pt + S/fact
}
library(imager)
install.packages('imager')
library(imager)
install.packages('ImageMagick')
gausskern <-
function(siz, sigma, muadv = 0){
x = 1:round(siz);
mu = c(mean(x), mean(x)) + muadv;
fx = (matrix(exp((-0.5*(x-mu[1])/sigma)^2))/(sqrt(2*pi)*sigma));
options(digits=5)
fx = exp(-.5*((x-mu[1])/sigma)^2)/sqrt((2*pi)*sigma)
fy = exp(-.5*((x-mu[2])/sigma)^2)/sqrt((2*pi)*sigma)
fx[!is.finite(fx)] = 0
#fy = (matrix(exp((-0.5*((x-mu[2])/sigma))^2))/(sqrt(2*pi)*sigma));
fy[!is.finite(fy)] = 0
kern = (fx%*%t(fy))
kern = kern/(sum(sum(kern,na.rm=T),na.rm=T))
kern[is.nan(kern)]=0
kern
}
d1 = 10
gk = gausskern(d1, 3)
gk = (array(gk, dim = c(10,10,1,1)))
devtools::install_github("dahtah/imager")
